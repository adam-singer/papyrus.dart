<!DOCTYPE html>

<!-- generated by papyrus on 6/12/2013 -->

<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>dart.async</title>
	<link href="bootstrap.css" rel="stylesheet" media="screen">
</head>

<body>
<header>
</header>
<div class='container'>
<div class='row'>
<div class='span3'>
	<ul class="nav nav-tabs nav-stacked left-nav">
		<li class="active"><a href="dart.async.html"><i class="chevron-nav icon-white icon-chevron-right"></i> dart.async</a></li>
		<li><a href="dart.collection.html"><i class="chevron-nav icon-chevron-right"></i> dart.collection</a></li>
		<li><a href="dart.core.html"><i class="chevron-nav icon-chevron-right"></i> dart.core</a></li>
		<li><a href="dart.dom.html.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.html</a></li>
		<li><a href="dart.dom.indexed_db.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.indexed_db</a></li>
		<li><a href="dart.dom.svg.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.svg</a></li>
		<li><a href="dart.dom.web_audio.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.web_audio</a></li>
		<li><a href="dart.dom.web_gl.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.web_gl</a></li>
		<li><a href="dart.dom.web_sql.html"><i class="chevron-nav icon-chevron-right"></i> dart.dom.web_sql</a></li>
		<li><a href="dart.io.html"><i class="chevron-nav icon-chevron-right"></i> dart.io</a></li>
		<li><a href="dart.isolate.html"><i class="chevron-nav icon-chevron-right"></i> dart.isolate</a></li>
		<li><a href="dart.json.html"><i class="chevron-nav icon-chevron-right"></i> dart.json</a></li>
		<li><a href="dart.math.html"><i class="chevron-nav icon-chevron-right"></i> dart.math</a></li>
		<li><a href="dart.mirrors.html"><i class="chevron-nav icon-chevron-right"></i> dart.mirrors</a></li>
		<li><a href="dart.typed_data.html"><i class="chevron-nav icon-chevron-right"></i> dart.typed_data</a></li>
		<li><a href="dart.utf.html"><i class="chevron-nav icon-chevron-right"></i> dart.utf</a></li>
	</ul>
</div>
<div class='span9'>
	<h1>dart.async</h1>
	<hr>
	<dl class=dl-horizontal>
		<dt>Functions</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#deprecatedFutureValue>deprecatedFutureValue</a>(_FutureImpl&lt;dynamic&gt; future): dynamic<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#getAttachedStackTrace>getAttachedStackTrace</a>(dynamic o): dynamic<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#runAsync>runAsync</a>(callback): void<br>
		</dd>
		<dt>Classes</dt>
		<dd>
			<i class=icon-leaf></i> <a href=dart.async.html#Completer>Completer</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#DeferredLibrary>DeferredLibrary</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#EventSink>EventSink</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#EventTransformStream>EventTransformStream</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#Stream>Stream</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamConsumer>StreamConsumer</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamController>StreamController</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamEventTransformer>StreamEventTransformer</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamIterator>StreamIterator</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamSink>StreamSink</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamSubscription>StreamSubscription</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamTransformer>StreamTransformer</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#StreamView>StreamView</a><br>
			<i class=icon-leaf></i> <a href=dart.async.html#Timer>Timer</a><br>
		</dd>
	</dl>
	<div class=indent></div>
	<h4>Functions</h4>
	<div class=indent>
		<b><a id=deprecatedFutureValue></a><i class=icon-ok-sign></i> static dynamic deprecatedFutureValue(_FutureImpl&lt;dynamic&gt; future)</b>
		<div class=indent></div>
		<b><a id=getAttachedStackTrace></a><i class=icon-ok-sign></i> static dynamic getAttachedStackTrace(dynamic o)</b>
		<div class=indent>
			<p><i>This is an experimental API.</i> </p>
<p>Get the <a class=code>StackTrace</a> attached to <a class=code>o</a>. </p>
<p>If object <a class=code>o</a> was thrown and caught in a dart:async method, a <a class=code>StackTrace</a> object was attached to it. Use <a class=code>getAttachedStackTrace</a> to get that object. </p>
<p>Returns <a class=code>null</a> if no <a class=code>StackTrace</a> was attached.</p>
		</div>
		<b><a id=runAsync></a><i class=icon-ok-sign></i> static void runAsync(callback)</b>
		<div class=indent>
			<p>Runs the given <a class=code>callback</a> asynchronously. </p>
<p>Callbacks registered through this function are always executed in order and are guaranteed to run before other asynchronous events (like <a class=code>Timer</a> events, or DOM events). </p>
<p>Warning: it is possible to starve the DOM by registering asynchronous callbacks through this method. For example the following program will run the callbacks without ever giving the Timer callback a chance to execute: </p>
<p><pre>Timer.run(() { print("executed"); });  // Will never be executed;
foo() {
  asyncRun(foo);  // Schedules [foo] in front of other events.
}
main() {
  foo();
}
</pre></p>
		</div>
	</div>
	<a id=Completer></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class Completer</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Completer.future>future</a>: <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Completer.isCompleted>isCompleted</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#future>future</a>: <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isCompleted>isCompleted</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Completer.>Completer</a>()<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Completer.sync>Completer.sync</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Completer.complete>complete</a>(T value): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Completer.completeError>completeError</a>(<a href=dart.core.html#Object>Object</a> exception, <a href=dart.core.html#Object>Object</a> stackTrace): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A <a class=code>Completer</a> is used to produce <a class=code>Future</a>s and supply their value when it becomes available. </p>
<p>A service that provides values to callers, and wants to return <a class=code>Future</a>s can use a <a class=code>Completer</a> as follows: </p>
<p><pre>Completer completer = new Completer();
// send future object back to client...
return completer.future;
...

// later when value is available, call:
completer.complete(value);

// alternatively, if the service cannot produce the value, it
// can provide an error:
completer.completeError(error);
</pre></p>
	</div>
	<h4>Fields</h4>
	<b><a id=Completer.future></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> future</b>
	<div class=indent></div>
	<b><a id=Completer.isCompleted></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isCompleted</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=future></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; get future</b>
	<div class=indent>
		<p>The future that will contain the result provided to this completer.</p>
	</div>
	<b><a id=isCompleted></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isCompleted</b>
	<div class=indent>
		<p>Whether the future has been completed.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=Completer.></a><i class=icon-plus-sign></i> factory Completer()</b>
	<div class=indent></div>
	<b><a id=Completer.sync></a><i class=icon-plus-sign></i> factory Completer.sync()</b>
	<div class=indent>
		<p>Completes the future synchronously. </p>
<p>This constructor should be avoided unless the completion of the future is known to be the final result of another asynchronous operation. If in doubt use the default <a class=code>Completer</a> constructor. </p>
<p>Example: </p>
<p><pre>var completer = new Completer.sync();
// The completion is the result of the asynchronous onDone event.
// No other operation is performed after the completion. It is safe
// to use the Completer.sync constructor.
stream.listen(print, onDone: () { completer.complete("done"); });
</pre>Bad example. Do not use this code. Only for illustrative purposes: </p>
<p><pre>var completer = new Completer.sync();
// The completion is the result of the asynchronous onDone event.
// However, there is still code executed after the completion. This
// operation is *not* safe.
stream.listen(print, onDone: () {
  completer.complete("done");
  foo();  // This operation follows the completion.
});
</pre><i>WARNING</i> This constructor is experimental and could disappear or change behavior.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=Completer.complete></a><i class=icon-ok-sign></i> void complete(T value)</b>
	<div class=indent>
		<p>Completes <a class=code>future</a> with the supplied values. </p>
<p>All listeners on the future will be immediately informed about the value.</p>
	</div>
	<b><a id=Completer.completeError></a><i class=icon-ok-sign></i> void completeError(<a href=dart.core.html#Object>Object</a> exception, <a href=dart.core.html#Object>Object</a> stackTrace)</b>
	<div class=indent>
		<p>Complete <a class=code>future</a> with an error. </p>
<p>Completing a future with an error indicates that an exception was thrown while trying to produce a value. </p>
<p>The argument <a class=code>exception</a> should not be <code>null</code>.</p>
	</div>
	<a id=DeferredLibrary></a><hr>
	<h4>
		<i class=icon-leaf></i> Class DeferredLibrary</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#DeferredLibrary.libraryName>libraryName</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#DeferredLibrary.uri>uri</a>: <a href=dart.core.html#String>String</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#DeferredLibrary.>DeferredLibrary</a>(<a href=dart.core.html#String>String</a> libraryName, <a href=dart.core.html#String>String</a> uri)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#DeferredLibrary.load>load</a>(): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>Indicates that loading of <a class=code>libraryName</a> is deferred. </p>
<p>Applies to library imports, when used as metadata. </p>
<p>Example usage: </p>
<p><pre>@lazy
import 'foo.dart' as foo;

const lazy = const DeferredLibrary('com.example.foo');

void main() {
  foo.method(); // Throws a NoSuchMethodError, foo is not loaded yet.
  lazy.load().then(onFooLoaded);
}

void onFooLoaded(_) {
  foo.method();
}
</pre></p>
	</div>
	<h4>Fields</h4>
	<b><a id=DeferredLibrary.libraryName></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> libraryName</b>
	<div class=indent></div>
	<b><a id=DeferredLibrary.uri></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> uri</b>
	<div class=indent></div>
	<h4>Constructors</h4>
	<b><a id=DeferredLibrary.></a><i class=icon-plus-sign></i> DeferredLibrary(<a href=dart.core.html#String>String</a> libraryName, <a href=dart.core.html#String>String</a> uri)</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=DeferredLibrary.load></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; load()</b>
	<div class=indent>
		<p>Ensure that <a class=code>libraryName</a> has been loaded. </p>
<p>The value of the returned future is true if this invocation of <a class=code>load</a> caused the library to be loaded.</p>
	</div>
	<a id=EventSink></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class EventSink</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#EventSink.>EventSink</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#EventSink.add>add</a>(T event): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#EventSink.addError>addError</a>(dynamic errorEvent): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#EventSink.close>close</a>(): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>An interface that abstracts creation or handling of <a class=code>Stream</a> events.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=EventSink.></a><i class=icon-plus-sign></i> EventSink()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=EventSink.add></a><i class=icon-ok-sign></i> void add(T event)</b>
	<div class=indent>
		<p>Create a data event</p>
	</div>
	<b><a id=EventSink.addError></a><i class=icon-ok-sign></i> void addError(dynamic errorEvent)</b>
	<div class=indent>
		<p>Create an async error.</p>
	</div>
	<b><a id=EventSink.close></a><i class=icon-ok-sign></i> void close()</b>
	<div class=indent>
		<p>Request a stream to close.</p>
	</div>
	<a id=EventTransformStream></a><hr>
	<h4>
		<i class=icon-leaf></i> Class EventTransformStream extends <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#EventTransformStream.>EventTransformStream</a>(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; source, <a href=dart.async.html#StreamEventTransformer>StreamEventTransformer</a>&lt;S, T&gt; transformer)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#EventTransformStream.listen>listen</a>(onData, onError, onDone, <a href=dart.core.html#bool>bool</a> cancelOnError): <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>Stream that transforms another stream by intercepting and replacing events. </p>
<p>This <a class=code>Stream</a> is a transformation of a source stream. Listening on this stream is the same as listening on the source stream, except that events are intercepted and modified by a <a class=code>StreamEventTransformer</a> before becoming events on this stream.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=EventTransformStream.></a><i class=icon-plus-sign></i> EventTransformStream(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; source, <a href=dart.async.html#StreamEventTransformer>StreamEventTransformer</a>&lt;S, T&gt; transformer)</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=EventTransformStream.listen></a><i class=icon-ok-sign></i> <a href='dart.async.html#Stream.listen'><i title='Overrides Stream.listen()' class='icon-circle-arrow-up'></i></a> <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt; listen(onData, onError, onDone, <a href=dart.core.html#bool>bool</a> cancelOnError)</b>
	<div class=indent>
		<p>Adds a subscription to this stream. </p>
<p>On each data event from this stream, the subscriber's <a class=code>onData</a> handler is called. If <a class=code>onData</a> is null, nothing happens. </p>
<p>On errors from this stream, the <a class=code>onError</a> handler is given a object describing the error. </p>
<p>If this stream closes, the <a class=code>onDone</a> handler is called. </p>
<p>If <a class=code>cancelOnError</a> is true, the subscription is ended when the first error is reported. The default is false.</p>
	</div>
	<a id=Future></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class Future</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Future.>Future</a>(computation)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Future.delayed>Future.delayed</a>(<a href=dart.core.html#Duration>Duration</a> duration, computation)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Future.error>Future.error</a>(dynamic error, <a href=dart.core.html#Object>Object</a> stackTrace)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Future.sync>Future.sync</a>(computation)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Future.value>Future.value</a>(T value)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.asStream>asStream</a>(): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.catchError>catchError</a>(onError, test): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.forEach>forEach</a>(<a href=dart.core.html#Iterable>Iterable</a>&lt;dynamic&gt; input, f): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.then>then</a>(onValue, onError): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.wait>wait</a>(<a href=dart.core.html#Iterable>Iterable</a>&lt;<a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;&gt; futures): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#List>List</a>&lt;dynamic&gt;&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Future.whenComplete>whenComplete</a>(action): <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A <a class=code>Future</a> represents a delayed computation. It is used to obtain a not-yet available value, or error, sometime in the future.  Receivers of a <a class=code>Future</a> can register callbacks that handle the value or error once it is available. For example: </p>
<p><pre>Future&lt;int&gt; future = getFuture();
future.then((value) =&gt; handleValue(value))
      .catchError((error) =&gt; handleError(error));
</pre>A <a class=code>Future</a> can be completed in two ways: with a value ("the future succeeds") or with an error ("the future fails"). Users can install callbacks for each case. The result of registering a pair of callbacks is a new Future (the "successor") which in turn is completed with the result of invoking the corresponding callback. The successor is completed with an error if the invoked callback throws. For example: </p>
<p><pre>Future&lt;int&gt; successor = future.then((int value) {
    // Invoked when the future is completed with a value.
    return 42;  // The successor is completed with the value 42.
  },
  onError: (e) {
    // Invoked when the future is completed with an error.
    if (canHandle(e)) {
      return 499;  // The successor is completed with the value 499.
    } else {
      throw e;  // The successor is completed with the error e.
    }
  });
</pre>If a future does not have a successor but is completed with an error, it forwards the error message to the global error-handler. This special casing makes sure that no error is silently dropped. However, it also means that error handlers should be installed early, so that they are present as soon as a future is completed with an error. The following example demonstrates this potential bug: </p>
<p><pre>var future = getFuture();
new Timer(new Duration(milliseconds: 5), () {
  // The error-handler is only attached 5ms after the future has been
  // received. If the future fails in the mean-time it will forward the
  // error to the global error-handler, even though there is code (just
  // below) to handle the error.
  future.then((value) { useValue(value); },
              onError: (e) { handleError(e); });
});
</pre>In general we discourage registering the two callbacks at the same time, but prefer to use <a class=code>then</a> with one argument (the value handler), and to use <a class=code>catchError</a> for handling errors. The missing callbacks (the error-handler for <a class=code>then</a>, and the value-handler for <a class=code>catchError</a>), are automatically configured to "forward" the value/error. Separating value and error-handling into separate registration calls usually leads to code that is easier to reason about. In fact it makes asynchronous code very similar to synchronous code: </p>
<p><pre>// Synchronous code.
try {
  int value = foo();
  return bar(value);
} catch (e) {
  return 499;
}
</pre>Equivalent asynchronous code, based on futures: </p>
<p><pre>Future&lt;int&gt; future = foo();  // foo now returns a future.
future.then((int value) =&gt; bar(value))
      .catchError((e) =&gt; 499);
</pre>Similar to the synchronous code, the error handler (registered with <a class=code>catchError</a>) is handling the errors for exceptions coming from calls to 'foo', as well as 'bar'. This would not be the case if the error-handler was registered at the same time as the value-handler. </p>
<p>Futures can have more than one callback-pairs registered. Each successor is treated independently and is handled as if it was the only successor.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=Future.></a><i class=icon-plus-sign></i> factory Future(computation)</b>
	<div class=indent>
		<p>Creates a future containing the result of calling <a class=code>computation</a> asynchronously with <a class=code>runAsync</a>. </p>
<p>if the result of executing <a class=code>computation</a> throws, the returned future is completed with the error. If a thrown value is an <a class=code>AsyncError</a>, it is used directly, instead of wrapping this error again in another <a class=code>AsyncError</a>. </p>
<p>If the returned value is itself a <a class=code>Future</a>, completion of the created future will wait until the returned future completes, and will then complete with the same result. </p>
<p>If a value is returned, it becomes the result of the created future.</p>
	</div>
	<b><a id=Future.delayed></a><i class=icon-plus-sign></i> factory Future.delayed(<a href=dart.core.html#Duration>Duration</a> duration, computation)</b>
	<div class=indent>
		<p>Creates a future that completes after a delay. </p>
<p>The future will be completed after the given <a class=code>duration</a> has passed with the result of calling <a class=code>computation</a>. If the duration is 0 or less, it completes no sooner than in the next event-loop iteration. </p>
<p>If <a class=code>computation</a> is not given or <code>null</code> then it will behave as if <a class=code>computation</a> was set to <code>() =&gt; null</code>. That is, it will complete with <code>null</code>. </p>
<p>If calling <a class=code>computation</a> throws, the created future will complete with the error. </p>
<p>See <a class=code>Completer</a>s, for futures with values that are computed asynchronously.</p>
	</div>
	<b><a id=Future.error></a><i class=icon-plus-sign></i> factory Future.error(dynamic error, <a href=dart.core.html#Object>Object</a> stackTrace)</b>
	<div class=indent>
		<p>A future that completes with an error in the next event-loop iteration. </p>
<p>See <a class=code>Completer</a> to create a Future and complete it later.</p>
	</div>
	<b><a id=Future.sync></a><i class=icon-plus-sign></i> factory Future.sync(computation)</b>
	<div class=indent>
		<p>Creates a future containing the result of immediately calling <a class=code>computation</a>. </p>
<p>if the result of executing <a class=code>computation</a> throws, the returned future is completed with the error. If a thrown value is an <a class=code>AsyncError</a>, it is used directly, instead of wrapping this error again in another <a class=code>AsyncError</a>. </p>
<p>If the returned value is itself a <a class=code>Future</a>, completion of the created future will wait until the returned future completes, and will then complete with the same result.</p>
	</div>
	<b><a id=Future.value></a><i class=icon-plus-sign></i> factory Future.value(T value)</b>
	<div class=indent>
		<p>A future whose value is available in the next event-loop iteration. </p>
<p>If <a class=code>value</a> is not a <a class=code>Future</a>, using this constructor is equivalent to <code>new Future.sync(() =&gt; value)</code>. </p>
<p>See <a class=code>Completer</a> to create a Future and complete it later.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=Future.asStream></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; asStream()</b>
	<div class=indent>
		<p>Creates a <a class=code>Stream</a> that sends <a class=code>this</a>' completion value, data or error, to its subscribers. The stream closes after the completion value.</p>
	</div>
	<b><a id=Future.catchError></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; catchError(onError, test)</b>
	<div class=indent>
		<p>Handles errors emitted by this <a class=code>Future</a>. </p>
<p>Returns a new <a class=code>Future</a> <code>f</code>. </p>
<p>When <a class=code>this</a> completes with a value, the value is forwarded to <code>f</code> unmodified. That is, <code>f</code> completes with the same value. </p>
<p>When <a class=code>this</a> completes with an error, <a class=code>test</a> is called with the error's value. If the invocation returns <a class=code>true</a>, <a class=code>onError</a> is called with the error. The result of <a class=code>onError</a> is handled exactly the same as for <a class=code>then</a>'s <a class=code>onError</a>. </p>
<p>If <a class=code>test</a> returns false, the exception is not handled by <a class=code>onError</a>, but is thrown unmodified, thus forwarding it to <code>f</code>. </p>
<p>If <a class=code>test</a> is omitted, it defaults to a function that always returns true. </p>
<p>Example: </p>
<p><pre>foo
  .catchError(..., test: (e) =&gt; e is ArgumentError)
  .catchError(..., test: (e) =&gt; e is NoSuchMethodError)
  .then((v) { ... });
</pre>This method is equivalent to: </p>
<p><pre>Future catchError(onError(error),
                  {bool test(error)}) {
  this.then((v) =&gt; v,  // Forward the value.
            // But handle errors, if the [test] succeeds.
            onError: (e) {
              if (test == null || test(e)) {
                return onError(e);
              }
              throw e;
            });
}
</pre></p>
	</div>
	<b><a id=Future.forEach></a><i class=icon-ok-sign></i> static <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; forEach(<a href=dart.core.html#Iterable>Iterable</a>&lt;dynamic&gt; input, f)</b>
	<div class=indent>
		<p>Perform an async operation for each element of the iterable, in turn. </p>
<p>Runs <a class=code>f</a> for each element in <a class=code>input</a> in order, moving to the next element only when the <a class=code>Future</a> returned by <a class=code>f</a> completes. Returns a <a class=code>Future</a> that completes when all elements have been processed. </p>
<p>The return values of all <a class=code>Future</a>s are discarded. Any errors will cause the iteration to stop and will be piped through the returned <a class=code>Future</a>.</p>
	</div>
	<b><a id=Future.then></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; then(onValue, onError)</b>
	<div class=indent>
		<p>When this future completes with a value, then <a class=code>onValue</a> is called with this value. If <a class=code>this</a> future is already completed then the invocation of <a class=code>onValue</a> is delayed until the next event-loop iteration. </p>
<p>Returns a new <a class=code>Future</a> <code>f</code> which is completed with the result of invoking <a class=code>onValue</a> (if <a class=code>this</a> completes with a value) or <a class=code>onError</a> (if <a class=code>this</a> completes with an error). </p>
<p>If the invoked callback throws an exception, the returned future <code>f</code> is completed with the error. </p>
<p>If the invoked callback returns a <a class=code>Future</a> <code>f2</code> then <code>f</code> and <code>f2</code> are chained. That is, <code>f</code> is completed with the completion value of <code>f2</code>. </p>
<p>If <a class=code>onError</a> is not given, it is equivalent to <code>(e) { throw e; }</code>. That is, it forwards the error to <code>f</code>. </p>
<p>In most cases, it is more readable to use <a class=code>catchError</a> separately, possibly with a <code>test</code> parameter, instead of handling both value and error in a single <a class=code>then</a> call.</p>
	</div>
	<b><a id=Future.wait></a><i class=icon-ok-sign></i> static <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#List>List</a>&lt;dynamic&gt;&gt; wait(<a href=dart.core.html#Iterable>Iterable</a>&lt;<a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;&gt; futures)</b>
	<div class=indent>
		<p>Wait for all the given futures to complete and collect their values. </p>
<p>Returns a future which will complete once all the futures in a list are complete. If any of the futures in the list completes with an error, the resulting future also completes with an error. Otherwise the value of the returned future will be a list of all the values that were produced.</p>
	</div>
	<b><a id=Future.whenComplete></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; whenComplete(action)</b>
	<div class=indent>
		<p>Register a function to be called when this future completes. </p>
<p>The <a class=code>action</a> function is called when this future completes, whether it does so with a value or with an error. </p>
<p>This is the asynchronous equivalent of a "finally" block. </p>
<p>The future returned by this call, <code>f</code>, will complete the same way as this future unless an error occurs in the <a class=code>action</a> call, or in a <a class=code>Future</a> returned by the <a class=code>action</a> call. If the call to <a class=code>action</a> does not return a future, its return value is ignored. </p>
<p>If the call to <a class=code>action</a> throws, then <code>f</code> is completed with the thrown error. </p>
<p>If the call to <a class=code>action</a> returns a <a class=code>Future</a>, <code>f2</code>, then completion of <code>f</code> is delayed until <code>f2</code> completes. If <code>f2</code> completes with an error, that will be the result of <code>f</code> too. The value of <code>f2</code> is always ignored. </p>
<p>This method is equivalent to: </p>
<p><pre>Future&lt;T&gt; whenComplete(action()) {
  this.then((v) {
              var f2 = action();
              if (f2 is Future) return f2.then((_) =&gt; v);
              return v
            },
            onError: (e) {
              var f2 = action();
              if (f2 is Future) return f2.then((_) { throw e; });
              throw e;
            });
}
</pre></p>
	</div>
	<a id=Stream></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class Stream</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.first>first</a>: <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.isBroadcast>isBroadcast</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.isEmpty>isEmpty</a>: <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.last>last</a>: <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.length>length</a>: <a href=dart.async.html#Future>Future</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#Stream.single>single</a>: <a href=dart.async.html#Future>Future</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#first>first</a>: <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isBroadcast>isBroadcast</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isEmpty>isEmpty</a>: <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#last>last</a>: <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#length>length</a>: <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#int>int</a>&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#single>single</a>: <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Stream.>Stream</a>()<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Stream.fromFuture>Stream.fromFuture</a>(<a href=dart.async.html#Future>Future</a>&lt;T&gt; future)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Stream.fromIterable>Stream.fromIterable</a>(<a href=dart.core.html#Iterable>Iterable</a>&lt;T&gt; data)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Stream.periodic>Stream.periodic</a>(<a href=dart.core.html#Duration>Duration</a> period, computation)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.any>any</a>(test): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.asBroadcastStream>asBroadcastStream</a>(): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.contains>contains</a>(T match): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.distinct>distinct</a>(equals): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.drain>drain</a>(dynamic futureValue): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.elementAt>elementAt</a>(<a href=dart.core.html#int>int</a> index): <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.every>every</a>(test): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.expand>expand</a>(convert): <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.firstWhere>firstWhere</a>(test, defaultValue): <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.fold>fold</a>(dynamic initialValue, combine): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.forEach>forEach</a>(action): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.handleError>handleError</a>(handle, test): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.lastWhere>lastWhere</a>(test, defaultValue): <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.listen>listen</a>(onData, onError, onDone, <a href=dart.core.html#bool>bool</a> cancelOnError): <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.map>map</a>(convert): <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.pipe>pipe</a>(<a href=dart.async.html#StreamConsumer>StreamConsumer</a>&lt;T&gt; streamConsumer): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.reduce>reduce</a>(combine): <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.singleWhere>singleWhere</a>(test): <a href=dart.async.html#Future>Future</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.skip>skip</a>(<a href=dart.core.html#int>int</a> count): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.skipWhile>skipWhile</a>(test): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.take>take</a>(<a href=dart.core.html#int>int</a> count): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.takeWhile>takeWhile</a>(test): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.toList>toList</a>(): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#List>List</a>&lt;T&gt;&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.toSet>toSet</a>(): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#Set>Set</a>&lt;T&gt;&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.transform>transform</a>(<a href=dart.async.html#StreamTransformer>StreamTransformer</a>&lt;T, dynamic&gt; streamTransformer): <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Stream.where>where</a>(test): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A source of asynchronous data events. </p>
<p>A Stream provides a sequence of events. Each event is either a data event or an error event, representing the result of a single computation. When the Stream is exhausted, it may send a single "done" event. </p>
<p>You can <a class=code>listen</a> on a stream to receive the events it sends. When you listen, you receive a <a class=code>StreamSubscription</a> object that can be used to stop listening, or to temporarily pause events from the stream. </p>
<p>When an event is fired, the listeners at that time are informed. If a listener is added while an event is being fired, the change will only take effect after the event is completely fired. If a listener is canceled, it immediately stops receiving events. </p>
<p>When the "done" event is fired, subscribers are unsubscribed before receiving the event. After the event has been sent, the stream has no subscribers. Adding new subscribers after this point is allowed, but they will just receive a new "done" event as soon as possible. </p>
<p>Streams always respect "pause" requests. If necessary they need to buffer their input, but often, and preferably, they can simply request their input to pause too. </p>
<p>There are two kinds of streams: The normal "single-subscription" streams and "broadcast" streams. </p>
<p>A single-subscription stream allows only a single listener at a time. It holds back events until it gets a listener, and it may exhaust itself when the listener is unsubscribed, even if the stream wasn't done. </p>
<p>Single-subscription streams are generally used for streaming parts of contiguous data like file I/O. </p>
<p>A broadcast stream allows any number of listeners, and it fires its events when they are ready, whether there are listeners or not. </p>
<p>Broadcast streams are used for independent events/observers. </p>
<p>The default implementation of <a class=code>isBroadcast</a> returns false. A broadcast stream inheriting from <a class=code>Stream</a> must override <a class=code>isBroadcast</a> to return <code>true</code>.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=Stream.first></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> first</b>
	<div class=indent></div>
	<b><a id=Stream.isBroadcast></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isBroadcast</b>
	<div class=indent></div>
	<b><a id=Stream.isEmpty></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> isEmpty</b>
	<div class=indent></div>
	<b><a id=Stream.last></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> last</b>
	<div class=indent></div>
	<b><a id=Stream.length></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> length</b>
	<div class=indent></div>
	<b><a id=Stream.single></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> single</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=first></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; get first</b>
	<div class=indent>
		<p>Returns the first element. </p>
<p>If <a class=code>this</a> is empty throws a <a class=code>StateError</a>. Otherwise this method is equivalent to <code>this.elementAt(0)</code></p>
	</div>
	<b><a id=isBroadcast></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isBroadcast</b>
	<div class=indent>
		<p>Reports whether this stream is a broadcast stream.</p>
	</div>
	<b><a id=isEmpty></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; get isEmpty</b>
	<div class=indent>
		<p>Reports whether this stream contains any elements.</p>
	</div>
	<b><a id=last></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; get last</b>
	<div class=indent>
		<p>Returns the last element. </p>
<p>If <a class=code>this</a> is empty throws a <a class=code>StateError</a>.</p>
	</div>
	<b><a id=length></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#int>int</a>&gt; get length</b>
	<div class=indent>
		<p>Counts the elements in the stream.</p>
	</div>
	<b><a id=single></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; get single</b>
	<div class=indent>
		<p>Returns the single element. </p>
<p>If <a class=code>this</a> is empty or has more than one element throws a <a class=code>StateError</a>.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=Stream.></a><i class=icon-plus-sign></i> Stream()</b>
	<div class=indent></div>
	<b><a id=Stream.fromFuture></a><i class=icon-plus-sign></i> factory Stream.fromFuture(<a href=dart.async.html#Future>Future</a>&lt;T&gt; future)</b>
	<div class=indent>
		<p>Creates a new single-subscription stream from the future. </p>
<p>When the future completes, the stream will fire one event, either data or error, and then close with a done-event.</p>
	</div>
	<b><a id=Stream.fromIterable></a><i class=icon-plus-sign></i> factory Stream.fromIterable(<a href=dart.core.html#Iterable>Iterable</a>&lt;T&gt; data)</b>
	<div class=indent>
		<p>Creates a single-subscription stream that gets its data from <a class=code>data</a>.</p>
	</div>
	<b><a id=Stream.periodic></a><i class=icon-plus-sign></i> factory Stream.periodic(<a href=dart.core.html#Duration>Duration</a> period, computation)</b>
	<div class=indent>
		<p>Creates a stream that repeatedly emits events at <a class=code>period</a> intervals. </p>
<p>The event values are computed by invoking <a class=code>computation</a>. The argument to this callback is an integer that starts with 0 and is incremented for every event. </p>
<p>If <a class=code>computation</a> is omitted the event values will all be <code>null</code>.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=Stream.any></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; any(test)</b>
	<div class=indent>
		<p>Checks whether <a class=code>test</a> accepts any element provided by this stream. </p>
<p>Completes the <a class=code>Future</a> when the answer is known. If this stream reports an error, the <a class=code>Future</a> will report that error.</p>
	</div>
	<b><a id=Stream.asBroadcastStream></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; asBroadcastStream()</b>
	<div class=indent>
		<p>Returns a multi-subscription stream that produces the same events as this. </p>
<p>If this stream is single-subscription, return a new stream that allows multiple subscribers. It will subscribe to this stream when its first subscriber is added, and unsubscribe again when the last subscription is canceled. </p>
<p>If this stream is already a broadcast stream, it is returned unmodified.</p>
	</div>
	<b><a id=Stream.contains></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; contains(T match)</b>
	<div class=indent>
		<p>Checks whether <a class=code>match</a> occurs in the elements provided by this stream. </p>
<p>Completes the <a class=code>Future</a> when the answer is known. If this stream reports an error, the <a class=code>Future</a> will report that error.</p>
	</div>
	<b><a id=Stream.distinct></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; distinct(equals)</b>
	<div class=indent>
		<p>Skips data events if they are equal to the previous data event. </p>
<p>The returned stream provides the same events as this stream, except that it never provides two consequtive data events that are equal. </p>
<p>Equality is determined by the provided <a class=code>equals</a> method. If that is omitted, the '==' operator on the last provided data element is used.</p>
	</div>
	<b><a id=Stream.drain></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; drain(dynamic futureValue)</b>
	<div class=indent>
		<p>Discards all data on the stream, but signals when it's done or an error occured. </p>
<p>When subscribing using <a class=code>drain</a>, cancelOnError will be true. This means that the future will complete with the first error on the stream and then cancel the subscription. </p>
<p>In case of a <code>done</code> event the future completes with the given <a class=code>futureValue</a>.</p>
	</div>
	<b><a id=Stream.elementAt></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; elementAt(<a href=dart.core.html#int>int</a> index)</b>
	<div class=indent>
		<p>Returns the value of the <a class=code>index</a>th data event of this stream. </p>
<p>If an error event occurs, the future will end with this error. </p>
<p>If this stream provides fewer than <a class=code>index</a> elements before closing, an error is reported.</p>
	</div>
	<b><a id=Stream.every></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; every(test)</b>
	<div class=indent>
		<p>Checks whether <a class=code>test</a> accepts all elements provided by this stream. </p>
<p>Completes the <a class=code>Future</a> when the answer is known. If this stream reports an error, the <a class=code>Future</a> will report that error.</p>
	</div>
	<b><a id=Stream.expand></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt; expand(convert)</b>
	<div class=indent>
		<p>Creates a new stream from this stream that converts each element into zero or more events. </p>
<p>Each incoming event is converted to an <a class=code>Iterable</a> of new events, and each of these new events are then sent by the returned stream in order.</p>
	</div>
	<b><a id=Stream.firstWhere></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; firstWhere(test, defaultValue)</b>
	<div class=indent>
		<p>Finds the first element of this stream matching <a class=code>test</a>. </p>
<p>Returns a future that is filled with the first element of this stream that <a class=code>test</a> returns true for. </p>
<p>If no such element is found before this stream is done, and a <a class=code>defaultValue</a> function is provided, the result of calling <a class=code>defaultValue</a> becomes the value of the future. </p>
<p>If an error occurs, or if this stream ends without finding a match and with no <a class=code>defaultValue</a> function provided, the future will receive an error.</p>
	</div>
	<b><a id=Stream.fold></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; fold(dynamic initialValue, combine)</b>
	<div class=indent>
		<p>Reduces a sequence of values by repeatedly applying <a class=code>combine</a>.</p>
	</div>
	<b><a id=Stream.forEach></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; forEach(action)</b>
	<div class=indent>
		<p>Executes <a class=code>action</a> on each data event of the stream. </p>
<p>Completes the returned <a class=code>Future</a> when all events of the stream have been processed. Completes the future with an error if the stream has an error event, or if <a class=code>action</a> throws.</p>
	</div>
	<b><a id=Stream.handleError></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; handleError(handle, test)</b>
	<div class=indent>
		<p>Creates a wrapper Stream that intercepts some errors from this stream. </p>
<p>If this stream sends an error that matches <a class=code>test</a>, then it is intercepted by the <a class=code>handle</a> function. </p>
<p>An <a class=code>AsyncError</a> <code>e</code> is matched by a test function if <code>test(e)</code> returns true. If <a class=code>test</a> is omitted, every error is considered matching. </p>
<p>If the error is intercepted, the <a class=code>handle</a> function can decide what to do with it. It can throw if it wants to raise a new (or the same) error, or simply return to make the stream forget the error. </p>
<p>If you need to transform an error into a data event, use the more generic <a class=code>Stream.transformEvent</a> to handle the event by writing a data event to the output sink</p>
	</div>
	<b><a id=Stream.lastWhere></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; lastWhere(test, defaultValue)</b>
	<div class=indent>
		<p>Finds the last element in this stream matching <a class=code>test</a>. </p>
<p>As <a class=code>firstWhere</a>, except that the last matching element is found. That means that the result cannot be provided before this stream is done.</p>
	</div>
	<b><a id=Stream.listen></a><i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt; listen(onData, onError, onDone, <a href=dart.core.html#bool>bool</a> cancelOnError)</b>
	<div class=indent>
		<p>Adds a subscription to this stream. </p>
<p>On each data event from this stream, the subscriber's <a class=code>onData</a> handler is called. If <a class=code>onData</a> is null, nothing happens. </p>
<p>On errors from this stream, the <a class=code>onError</a> handler is given a object describing the error. </p>
<p>If this stream closes, the <a class=code>onDone</a> handler is called. </p>
<p>If <a class=code>cancelOnError</a> is true, the subscription is ended when the first error is reported. The default is false.</p>
	</div>
	<b><a id=Stream.map></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt; map(convert)</b>
	<div class=indent>
		<p>Creates a new stream that converts each element of this stream to a new value using the <a class=code>convert</a> function.</p>
	</div>
	<b><a id=Stream.pipe></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; pipe(<a href=dart.async.html#StreamConsumer>StreamConsumer</a>&lt;T&gt; streamConsumer)</b>
	<div class=indent>
		<p>Binds this stream as the input of the provided <a class=code>StreamConsumer</a>.</p>
	</div>
	<b><a id=Stream.reduce></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; reduce(combine)</b>
	<div class=indent>
		<p>Reduces a sequence of values by repeatedly applying <a class=code>combine</a>.</p>
	</div>
	<b><a id=Stream.singleWhere></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;T&gt; singleWhere(test)</b>
	<div class=indent>
		<p>Finds the single element in this stream matching <a class=code>test</a>. </p>
<p>Like <a class=code>lastMatch</a>, except that it is an error if more than one matching element occurs in the stream.</p>
	</div>
	<b><a id=Stream.skip></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; skip(<a href=dart.core.html#int>int</a> count)</b>
	<div class=indent>
		<p>Skips the first <a class=code>count</a> data events from this stream.</p>
	</div>
	<b><a id=Stream.skipWhile></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; skipWhile(test)</b>
	<div class=indent>
		<p>Skip data events from this stream while they are matched by <a class=code>test</a>. </p>
<p>Error and done events are provided by the returned stream unmodified. </p>
<p>Starting with the first data event where <a class=code>test</a> returns true for the event data, the returned stream will have the same events as this stream.</p>
	</div>
	<b><a id=Stream.take></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; take(<a href=dart.core.html#int>int</a> count)</b>
	<div class=indent>
		<p>Provides at most the first <a class=code>n</a> values of this stream. </p>
<p>Forwards the first <a class=code>n</a> data events of this stream, and all error events, to the returned stream, and ends with a done event. </p>
<p>If this stream produces fewer than <a class=code>count</a> values before it's done, so will the returned stream.</p>
	</div>
	<b><a id=Stream.takeWhile></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; takeWhile(test)</b>
	<div class=indent>
		<p>Forwards data events while <a class=code>test</a> is successful. </p>
<p>The returned stream provides the same events as this stream as long as <a class=code>test</a> returns <code>true</code> for the event data. The stream is done when either this stream is done, or when this stream first provides a value that <a class=code>test</a> doesn't accept.</p>
	</div>
	<b><a id=Stream.toList></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#List>List</a>&lt;T&gt;&gt; toList()</b>
	<div class=indent>
		<p>Collects the data of this stream in a <a class=code>List</a>.</p>
	</div>
	<b><a id=Stream.toSet></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#Set>Set</a>&lt;T&gt;&gt; toSet()</b>
	<div class=indent>
		<p>Collects the data of this stream in a <a class=code>Set</a>.</p>
	</div>
	<b><a id=Stream.transform></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;dynamic&gt; transform(<a href=dart.async.html#StreamTransformer>StreamTransformer</a>&lt;T, dynamic&gt; streamTransformer)</b>
	<div class=indent>
		<p>Chains this stream as the input of the provided <a class=code>StreamTransformer</a>. </p>
<p>Returns the result of <code>streamTransformer.bind</code> itself.</p>
	</div>
	<b><a id=Stream.where></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; where(test)</b>
	<div class=indent>
		<p>Creates a new stream from this stream that discards some data events. </p>
<p>The new stream sends the same error and done events as this stream, but it only sends the data events that satisfy the <a class=code>test</a>.</p>
	</div>
	<a id=StreamConsumer></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamConsumer</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamConsumer.>StreamConsumer</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamConsumer.addStream>addStream</a>(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; stream): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamConsumer.close>close</a>(): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>The target of a <a class=code>Stream.pipe</a> call. </p>
<p>The <a class=code>Stream.pipe</a> call will pass itself to this object, and then return the resulting <a class=code>Future</a>. The pipe should complete the future when it's done.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamConsumer.></a><i class=icon-plus-sign></i> StreamConsumer()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=StreamConsumer.addStream></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; addStream(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; stream)</b>
	<div class=indent></div>
	<b><a id=StreamConsumer.close></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; close()</b>
	<div class=indent></div>
	<a id=StreamController></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamController implements <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt;</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamController.hasListener>hasListener</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamController.isClosed>isClosed</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamController.isPaused>isPaused</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamController.sink>sink</a>: <a href=dart.async.html#EventSink>EventSink</a><br>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamController.stream>stream</a>: <a href=dart.async.html#Stream>Stream</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#hasListener>hasListener</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isClosed>isClosed</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isPaused>isPaused</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#sink>sink</a>: <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt;<br>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#stream>stream</a>: <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamController.>StreamController</a>(onListen, onPause, onResume, onCancel, <a href=dart.core.html#bool>bool</a> sync)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamController.broadcast>StreamController.broadcast</a>(onListen, onCancel, <a href=dart.core.html#bool>bool</a> sync)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamController.addError>addError</a>(<a href=dart.core.html#Object>Object</a> error, <a href=dart.core.html#Object>Object</a> stackTrace): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A controller with the stream it controls. </p>
<p>This controller allows sending data, error and done events on its <a class=code>stream</a>. This class can be used to create a simple stream that others can listen on, and to push events to that stream. </p>
<p>It's possible to check whether the stream is paused or not, and whether it has subscribers or not, as well as getting a callback when either of these change. </p>
<p>If the stream starts or stops having listeners (first listener subscribing, last listener unsubscribing), the <code>onSubscriptionStateChange</code> callback is notified as soon as possible. If the subscription stat changes during an event firing or a callback being executed, the change will not be reported until the current event or callback has finished. If the pause state has also changed during an event or callback, only the subscription state callback is notified. </p>
<p>If the subscriber state has not changed, but the pause state has, the <code>onPauseStateChange</code> callback is notified as soon as possible, after firing a current event or completing another callback. This happens if the stream is not paused, and a listener pauses it, or if the stream has been resumed from pause and has no pending events. If the listeners resume a paused stream while it still has queued events, the controller will still consider the stream paused until all queued events have been dispatched. </p>
<p>Whether to invoke a callback depends only on the state before and after a stream action, for example firing an event. If the state changes multiple times during the action, and then ends up in the same state as before, no callback is performed. </p>
<p>If listeners are added after the stream has completed (sent a "done" event), the listeners will be sent a "done" event eventually, but they won't affect the stream at all, and won't trigger callbacks. From the controller's point of view, the stream is completely inert when has completed.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=StreamController.hasListener></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> hasListener</b>
	<div class=indent></div>
	<b><a id=StreamController.isClosed></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isClosed</b>
	<div class=indent></div>
	<b><a id=StreamController.isPaused></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isPaused</b>
	<div class=indent></div>
	<b><a id=StreamController.sink></a><i class=icon-minus-sign></i> final <a href=dart.async.html#EventSink>EventSink</a> sink</b>
	<div class=indent></div>
	<b><a id=StreamController.stream></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Stream>Stream</a> stream</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=hasListener></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get hasListener</b>
	<div class=indent>
		<p>Whether there is a subscriber on the <a class=code>Stream</a>.</p>
	</div>
	<b><a id=isClosed></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isClosed</b>
	<div class=indent>
		<p>Whether the stream is closed for adding more events. </p>
<p>If true, the "done" event might not have fired yet, but it has been scheduled, and it is too late to add more events.</p>
	</div>
	<b><a id=isPaused></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isPaused</b>
	<div class=indent>
		<p>Whether the subscription would need to buffer events. </p>
<p>This is the case if the controller's stream has a listener and it is paused, or if it has not received a listener yet. In that case, the controller is considered paused as well. </p>
<p>A broadcast stream controller is never considered paused. It always forwards its events to all uncanceled listeners, if any, and let them handle their own pausing.</p>
	</div>
	<b><a id=sink></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; get sink</b>
	<div class=indent>
		<p>Returns a view of this object that only exposes the <a class=code>EventSink</a> interface.</p>
	</div>
	<b><a id=stream></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; get stream</b>
	<div class=indent>
		<p>The stream that this controller is controlling.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamController.></a><i class=icon-plus-sign></i> factory StreamController(onListen, onPause, onResume, onCancel, <a href=dart.core.html#bool>bool</a> sync)</b>
	<div class=indent>
		<p>A controller with a <a class=code>stream</a> that supports only one single subscriber. </p>
<p>If <a class=code>sync</a> is true, events may be passed directly to the stream's listener during an <a class=code>add</a>, <a class=code>addError</a> or <a class=code>close</a> call. If <a class=code>sync</a> is false, the event will be passed to the listener at a later time, after the code creating the event has returned. </p>
<p>The controller will buffer all incoming events until the subscriber is registered. </p>
<p>The <a class=code>onPause</a> function is called when the stream becomes paused. <a class=code>onResume</a> is called when the stream resumed. </p>
<p>The <a class=code>onListen</a> callback is called when the stream receives its listener and <a class=code>onCancel</a> when the listener ends its subscription. </p>
<p>If the stream is canceled before the controller needs new data the <a class=code>onResume</a> call might not be executed.</p>
	</div>
	<b><a id=StreamController.broadcast></a><i class=icon-plus-sign></i> factory StreamController.broadcast(onListen, onCancel, <a href=dart.core.html#bool>bool</a> sync)</b>
	<div class=indent>
		<p>A controller where <a class=code>stream</a> can be listened to more than once. </p>
<p>The <a class=code>Stream</a> returned by <a class=code>stream</a> is a broadcast stream. It can be listened to more than once. </p>
<p>The controller distributes any events to all currently subscribed listeners. It is not allowed to call <a class=code>add</a>, <a class=code>addError</a>, or <a class=code>close</a> before a previous call has returned. </p>
<p>If <a class=code>sync</a> is true, events may be passed directly to the stream's listener during an <a class=code>add</a>, <a class=code>addError</a> or <a class=code>close</a> call. If <a class=code>sync</a> is false, the event will be passed to the listener at a later time, after the code creating the event has returned. </p>
<p>Each listener is handled independently, and if they pause, only the pausing listener is affected. A paused listener will buffer events internally until unpaused or canceled. </p>
<p>If <a class=code>sync</a> is false, no guarantees are given with regard to when multiple listeners get the events, except that each listener will get all events in the correct order. If two events are sent on an async controller with two listeners, one of the listeners may get both events before the other listener gets any. A listener must be subscribed both when the event is initiated (that is, when <a class=code>add</a> is called) and when the event is later delivered, in order to get the event. </p>
<p>The <a class=code>onListen</a> callback is called when the first listener is subscribed, and the <a class=code>onCancel</a> is called when there are no longer any active listeners. If a listener is added again later, after the <a class=code>onCancel</a> was called, the <a class=code>onListen</a> will be called again.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=StreamController.addError></a><i class=icon-ok-sign></i> <a href='dart.async.html#EventSink.addError'><i title='Overrides EventSink.addError()' class='icon-circle-arrow-up'></i></a> void addError(<a href=dart.core.html#Object>Object</a> error, <a href=dart.core.html#Object>Object</a> stackTrace)</b>
	<div class=indent>
		<p>Send or enqueue an error event. </p>
<p>Also allows an objection stack trace object, on top of what <a class=code>EventSink</a> allows.</p>
	</div>
	<a id=StreamEventTransformer></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamEventTransformer implements <a href=dart.async.html#StreamTransformer>StreamTransformer</a>&lt;S, T&gt;</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamEventTransformer.>StreamEventTransformer</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamEventTransformer.bind>bind</a>(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; source): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamEventTransformer.handleData>handleData</a>(S event, <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamEventTransformer.handleDone>handleDone</a>(<a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamEventTransformer.handleError>handleError</a>(dynamic error, <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>Base class for transformers that modifies stream events. </p>
<p>A <a class=code>StreamEventTransformer</a> transforms incoming Stream events of one kind into outgoing events of (possibly) another kind. </p>
<p>Subscribing on the stream returned by <a class=code>bind</a> is the same as subscribing on the source stream, except that events are passed through the <a class=code>transformer</a> before being emitted. The transformer may generate any number and types of events for each incoming event. Pauses on the returned subscription are forwarded to this stream. </p>
<p>An example that duplicates all data events: </p>
<p><pre>class DoubleTransformer&lt;T&gt; extends StreamEventTransformer&lt;T, T&gt; {
  void handleData(T data, EventSink&lt;T&gt; sink) {
    sink.add(value);
    sink.add(value);
  }
}
someTypeStream.transform(new DoubleTransformer&lt;Type&gt;());
</pre>The default implementations of the "handle" methods forward the events unmodified. If using the default <a class=code>handleData</a> the generic type <a class=code>T</a> needs to be assignable to <a class=code>S</a>.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamEventTransformer.></a><i class=icon-plus-sign></i> StreamEventTransformer()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=StreamEventTransformer.bind></a><i class=icon-ok-sign></i> <a href='dart.async.html#StreamTransformer.bind'><i title='Overrides StreamTransformer.bind()' class='icon-circle-arrow-up'></i></a> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; bind(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; source)</b>
	<div class=indent></div>
	<b><a id=StreamEventTransformer.handleData></a><i class=icon-ok-sign></i> void handleData(S event, <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink)</b>
	<div class=indent>
		<p>Act on incoming data event. </p>
<p>The method may generate any number of events on the sink, but should not throw.</p>
	</div>
	<b><a id=StreamEventTransformer.handleDone></a><i class=icon-ok-sign></i> void handleDone(<a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink)</b>
	<div class=indent>
		<p>Act on incoming done event. </p>
<p>The method may generate any number of events on the sink, but should not throw.</p>
	</div>
	<b><a id=StreamEventTransformer.handleError></a><i class=icon-ok-sign></i> void handleError(dynamic error, <a href=dart.async.html#EventSink>EventSink</a>&lt;T&gt; sink)</b>
	<div class=indent>
		<p>Act on incoming error event. </p>
<p>The method may generate any number of events on the sink, but should not throw.</p>
	</div>
	<a id=StreamIterator></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamIterator</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamIterator.current>current</a>: <a href=dart.async.html#T>T</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#current>current</a>: T<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamIterator.>StreamIterator</a>(<a href=dart.async.html#Stream>Stream</a>&lt;T&gt; stream)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamIterator.cancel>cancel</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamIterator.moveNext>moveNext</a>(): <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>An <a class=code>Iterable</a> like interface for the values of a <a class=code>Stream</a>. </p>
<p>This wraps a <a class=code>Stream</a> and a subscription on the stream. It listens on the stream, and completes the future returned by <a class=code>moveNext</a> when the next value becomes available. </p>
<p>NOTICE: This is a tentative design. This class may change.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=StreamIterator.current></a><i class=icon-minus-sign></i> final <a href=dart.async.html#T>T</a> current</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=current></a><i class=icon-circle-arrow-right></i> T get current</b>
	<div class=indent>
		<p>The current value of the stream. </p>
<p>Only valid when the future returned by <a class=code>moveNext</a> completes with <code>true</code> as value, and only until the next call to <a class=code>moveNext</a>.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamIterator.></a><i class=icon-plus-sign></i> factory StreamIterator(<a href=dart.async.html#Stream>Stream</a>&lt;T&gt; stream)</b>
	<div class=indent>
		<p>Create a <a class=code>StreamIterator</a> on <a class=code>stream</a>.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=StreamIterator.cancel></a><i class=icon-ok-sign></i> void cancel()</b>
	<div class=indent>
		<p>Cancels the stream iterator (and the underlying stream subscription) early. </p>
<p>The stream iterator is automatically canceled if the <a class=code>moveNext</a> future completes with either <code>false</code> or an error. </p>
<p>If a <a class=code>moveNext</a> call has been made, it will complete with <code>false</code> as value, as will all further calls to <a class=code>moveNext</a>. </p>
<p>If you need to stop listening for values before the stream iterator is automatically closed, you must call <a class=code>cancel</a> to ensure that the stream is properly closed.</p>
	</div>
	<b><a id=StreamIterator.moveNext></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;<a href=dart.core.html#bool>bool</a>&gt; moveNext()</b>
	<div class=indent>
		<p>Wait for the next stream value to be available. </p>
<p>It is not allowed to call this function again until the future has completed. If the returned future completes with anything except <code>true</code>, the iterator is done, and no new value will ever be available. </p>
<p>The future may complete with an error, if the stream produces an error.</p>
	</div>
	<a id=StreamSink></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamSink implements <a href=dart.async.html#StreamConsumer>StreamConsumer</a>&lt;S&gt;, <a href=dart.async.html#EventSink>EventSink</a>&lt;S&gt;</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamSink.done>done</a>: <a href=dart.async.html#Future>Future</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#done>done</a>: <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamSink.>StreamSink</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSink.close>close</a>(): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A <a class=code>StreamSink</a> unifies the asynchronous methods from <a class=code>StreamConsumer</a> and the synchronous methods from <a class=code>EventSink</a>. </p>
<p>The <a class=code>EventSink</a> methods can't be used while the <a class=code>addStream</a> is called. As soon as the <a class=code>addStream</a>'s <a class=code>Future</a> completes with a value, the <a class=code>EventSink</a> methods can be used again. </p>
<p>If <a class=code>addStream</a> is called after any of the <a class=code>EventSink</a> methods, it'll be delayed until the underlying system has consumed the data added by the <a class=code>EventSink</a> methods. </p>
<p>When <a class=code>EventSink</a> methods are used, the <a class=code>done</a> <a class=code>Future</a> can be used to catch any errors. </p>
<p>When <a class=code>close</a> is called, it will return the <a class=code>done</a> <a class=code>Future</a>.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=StreamSink.done></a><i class=icon-minus-sign></i> final <a href=dart.async.html#Future>Future</a> done</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=done></a><i class=icon-circle-arrow-right></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; get done</b>
	<div class=indent>
		<p>The <a class=code>done</a> Future completes with the same values as <a class=code>close</a>, except for the following case: </p>
<p><ul><li>The synchronous methods of <a class=code>EventSink</a> were called, resulting in an</li></ul>error. If there is no active future (like from an addStream call), the <a class=code>done</a> future will complete with that error</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamSink.></a><i class=icon-plus-sign></i> StreamSink()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=StreamSink.close></a><i class=icon-ok-sign></i> <a href='dart.async.html#StreamConsumer.close'><i title='Overrides StreamConsumer.close()' class='icon-circle-arrow-up'></i></a> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; close()</b>
	<div class=indent>
		<p>Close the <a class=code>StreamSink</a>. It'll return the <a class=code>done</a> Future.</p>
	</div>
	<a id=StreamSubscription></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamSubscription</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamSubscription.isPaused>isPaused</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isPaused>isPaused</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamSubscription.>StreamSubscription</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.asFuture>asFuture</a>(dynamic futureValue): <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.cancel>cancel</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.onData>onData</a>(handleData): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.onDone>onDone</a>(handleDone): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.onError>onError</a>(handleError): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.pause>pause</a>(<a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; resumeSignal): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamSubscription.resume>resume</a>(): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>A control object for the subscription on a <a class=code>Stream</a>. </p>
<p>When you subscribe on a <a class=code>Stream</a> using <a class=code>Stream.listen</a>, a <a class=code>StreamSubscription</a> object is returned. This object is used to later unsubscribe again, or to temporarily pause the stream's events.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=StreamSubscription.isPaused></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isPaused</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=isPaused></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isPaused</b>
	<div class=indent>
		<p>Returns true if the <a class=code>StreamSubscription</a> is paused.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamSubscription.></a><i class=icon-plus-sign></i> StreamSubscription()</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=StreamSubscription.asFuture></a><i class=icon-ok-sign></i> <a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; asFuture(dynamic futureValue)</b>
	<div class=indent>
		<p>Returns a future that handles the <a class=code>onDone</a> and <a class=code>onError</a> callbacks. </p>
<p>This method <i>overwrites</i> the existing <a class=code>onDone</a> and <a class=code>onError</a> callbacks with new ones that complete the returned future. </p>
<p>In case of an error the subscription will automatically cancel (even when it was listening with <code>cancelOnError</code> set to <code>false</code>). </p>
<p>In case of a <code>done</code> event the future completes with the given <a class=code>futureValue</a>.</p>
	</div>
	<b><a id=StreamSubscription.cancel></a><i class=icon-ok-sign></i> void cancel()</b>
	<div class=indent>
		<p>Cancels this subscription. It will no longer receive events. </p>
<p>If an event is currently firing, this unsubscription will only take effect after all subscribers have received the current event.</p>
	</div>
	<b><a id=StreamSubscription.onData></a><i class=icon-ok-sign></i> void onData(handleData)</b>
	<div class=indent>
		<p>Set or override the data event handler of this subscription.</p>
	</div>
	<b><a id=StreamSubscription.onDone></a><i class=icon-ok-sign></i> void onDone(handleDone)</b>
	<div class=indent>
		<p>Set or override the done event handler of this subscription.</p>
	</div>
	<b><a id=StreamSubscription.onError></a><i class=icon-ok-sign></i> void onError(handleError)</b>
	<div class=indent>
		<p>Set or override the error event handler of this subscription.</p>
	</div>
	<b><a id=StreamSubscription.pause></a><i class=icon-ok-sign></i> void pause(<a href=dart.async.html#Future>Future</a>&lt;dynamic&gt; resumeSignal)</b>
	<div class=indent>
		<p>Request that the stream pauses events until further notice. </p>
<p>If <a class=code>resumeSignal</a> is provided, the stream will undo the pause when the future completes. If the future completes with an error, it will not be handled! </p>
<p>A call to <a class=code>resume</a> will also undo a pause. </p>
<p>If the subscription is paused more than once, an equal number of resumes must be performed to resume the stream.</p>
	</div>
	<b><a id=StreamSubscription.resume></a><i class=icon-ok-sign></i> void resume()</b>
	<div class=indent>
		<p>Resume after a pause.</p>
	</div>
	<a id=StreamTransformer></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class StreamTransformer</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamTransformer.>StreamTransformer</a>(handleData, handleError, handleDone)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamTransformer.bind>bind</a>(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; stream): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p>The target of a <a class=code>Stream.transform</a> call. </p>
<p>The <a class=code>Stream.transform</a> call will pass itself to this object and then return the resulting stream.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=StreamTransformer.></a><i class=icon-plus-sign></i> factory StreamTransformer(handleData, handleError, handleDone)</b>
	<div class=indent>
		<p>Create a <a class=code>StreamTransformer</a> that delegates events to the given functions. </p>
<p>This is actually a <a class=code>StreamEventTransformer</a> where the event handling is performed by the function arguments. If an argument is omitted, it acts as the corresponding default method from <a class=code>StreamEventTransformer</a>. </p>
<p>Example use: </p>
<p><pre>stringStream.transform(new StreamTransformer&lt;String, String&gt;(
    handleData: (Strung value, EventSink&lt;String&gt; sink) {
      sink.add(value);
      sink.add(value);  // Duplicate the incoming events.
    }));
</pre></p>
	</div>
	<h4>Methods</h4>
	<b><a id=StreamTransformer.bind></a><i class=icon-ok-sign></i> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; bind(<a href=dart.async.html#Stream>Stream</a>&lt;S&gt; stream)</b>
	<div class=indent></div>
	<a id=StreamView></a><hr>
	<h4>
		<i class=icon-leaf></i> Class StreamView extends <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=dart.async.html#StreamView.isBroadcast>isBroadcast</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=dart.async.html#isBroadcast>isBroadcast</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#StreamView.>StreamView</a>(<a href=dart.async.html#Stream>Stream</a>&lt;T&gt; _stream)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamView.asBroadcastStream>asBroadcastStream</a>(): <a href=dart.async.html#Stream>Stream</a>&lt;T&gt;<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#StreamView.listen>listen</a>(onData, onError, onDone, <a href=dart.core.html#bool>bool</a> cancelOnError): <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt;<br>
		</dd>
	</dl>
	<div class=indent>
		<p><a class=code>Stream</a> wrapper that only exposes the <a class=code>Stream</a> interface.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=StreamView.isBroadcast></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isBroadcast</b>
	<div class=indent></div>
	<h4>Getters and Setters</h4>
	<b><a id=isBroadcast></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isBroadcast</b>
	<div class=indent></div>
	<h4>Constructors</h4>
	<b><a id=StreamView.></a><i class=icon-plus-sign></i> StreamView(<a href=dart.async.html#Stream>Stream</a>&lt;T&gt; _stream)</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=StreamView.asBroadcastStream></a><i class=icon-ok-sign></i> <a href='dart.async.html#Stream.asBroadcastStream'><i title='Overrides Stream.asBroadcastStream()' class='icon-circle-arrow-up'></i></a> <a href=dart.async.html#Stream>Stream</a>&lt;T&gt; asBroadcastStream()</b>
	<div class=indent>
		<p>Returns a multi-subscription stream that produces the same events as this. </p>
<p>If this stream is single-subscription, return a new stream that allows multiple subscribers. It will subscribe to this stream when its first subscriber is added, and unsubscribe again when the last subscription is canceled. </p>
<p>If this stream is already a broadcast stream, it is returned unmodified.</p>
	</div>
	<b><a id=StreamView.listen></a><i class=icon-ok-sign></i> <a href='dart.async.html#Stream.listen'><i title='Overrides Stream.listen()' class='icon-circle-arrow-up'></i></a> <a href=dart.async.html#StreamSubscription>StreamSubscription</a>&lt;T&gt; listen(onData, onError, onDone, <a href=dart.core.html#bool>bool</a> cancelOnError)</b>
	<div class=indent>
		<p>Adds a subscription to this stream. </p>
<p>On each data event from this stream, the subscriber's <a class=code>onData</a> handler is called. If <a class=code>onData</a> is null, nothing happens. </p>
<p>On errors from this stream, the <a class=code>onError</a> handler is given a object describing the error. </p>
<p>If this stream closes, the <a class=code>onDone</a> handler is called. </p>
<p>If <a class=code>cancelOnError</a> is true, the subscription is ended when the first error is reported. The default is false.</p>
	</div>
	<a id=Timer></a><hr>
	<h4>
		<i class=icon-leaf></i> Abstract class Timer</h4>
	<dl class=dl-horizontal>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Timer.>Timer</a>(<a href=dart.core.html#Duration>Duration</a> duration, callback)<br>
			<i class=icon-plus-sign></i> <a href=dart.async.html#Timer.periodic>Timer.periodic</a>(<a href=dart.core.html#Duration>Duration</a> duration, callback)<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Timer.cancel>cancel</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=dart.async.html#Timer.run>run</a>(callback): void<br>
		</dd>
	</dl>
	<div class=indent></div>
	<h4>Constructors</h4>
	<b><a id=Timer.></a><i class=icon-plus-sign></i> factory Timer(<a href=dart.core.html#Duration>Duration</a> duration, callback)</b>
	<div class=indent>
		<p>Creates a new timer. </p>
<p>The <a class=code>callback</a> callback is invoked after the given <a class=code>duration</a>. A negative duration is treated similar to a duration of 0. </p>
<p>If the <a class=code>duration</a> is statically known to be 0, consider using <a class=code>run</a>. </p>
<p>Frequently the <a class=code>duration</a> is either a constant or computed as in the following example (taking advantage of the multiplication operator of the Duration class): </p>
<p><pre>const TIMEOUT = const Duration(seconds: 3);
const ms = const Duration(milliseconds: 1);

startTimeout([int milliseconds]) {
  var duration = milliseconds == null ? TIMEOUT : ms * milliseconds;
  return new Timer(duration, handleTimeout);
}
</pre>Note: If Dart code using Timer is compiled to JavaScript, the finest granularity available in the browser is 4 milliseconds.</p>
	</div>
	<b><a id=Timer.periodic></a><i class=icon-plus-sign></i> factory Timer.periodic(<a href=dart.core.html#Duration>Duration</a> duration, callback)</b>
	<div class=indent>
		<p>Creates a new repeating timer. </p>
<p>The <a class=code>callback</a> is invoked repeatedly with <a class=code>duration</a> intervals until canceled. A negative duration is treated similar to a duration of 0.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=Timer.cancel></a><i class=icon-ok-sign></i> void cancel()</b>
	<div class=indent>
		<p>Cancels the timer.</p>
	</div>
	<b><a id=Timer.run></a><i class=icon-ok-sign></i> static void run(callback)</b>
	<div class=indent>
		<p>Runs the given <a class=code>callback</a> asynchronously as soon as possible. </p>
<p>This function is equivalent to <code>new Timer(Duration.ZERO, callback)</code>.</p>
	</div>
	<hr>
</div>
</div>
</div>
<footer>
</footer>
</body>
</html>
