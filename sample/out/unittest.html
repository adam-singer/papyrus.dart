<!DOCTYPE html>

<!-- generated by papyrus on 6/10/2013 -->

<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>unittest</title>
	<link href="bootstrap.css" rel="stylesheet" media="screen">
</head>

<body>
<header>
</header>
<div class='container'>
<div class='row'>
<div class='span3'>
	<ul class="nav nav-tabs nav-stacked left-nav">
		<li><a href="cmd_test.html"><i class="chevron-nav icon-chevron-right"></i> cmd_test</a></li>
		<li><a href="dart.async.html"><i class="chevron-nav icon-chevron-right"></i> dart.async</a></li>
		<li><a href="dart.collection.html"><i class="chevron-nav icon-chevron-right"></i> dart.collection</a></li>
		<li><a href="dart.core.html"><i class="chevron-nav icon-chevron-right"></i> dart.core</a></li>
		<li><a href="dart.isolate.html"><i class="chevron-nav icon-chevron-right"></i> dart.isolate</a></li>
		<li><a href="dart.math.html"><i class="chevron-nav icon-chevron-right"></i> dart.math</a></li>
		<li><a href="dart.utf.html"><i class="chevron-nav icon-chevron-right"></i> dart.utf</a></li>
		<li><a href="intl.html"><i class="chevron-nav icon-chevron-right"></i> intl</a></li>
		<li><a href="logging.html"><i class="chevron-nav icon-chevron-right"></i> logging</a></li>
		<li><a href="matcher.html"><i class="chevron-nav icon-chevron-right"></i> matcher</a></li>
		<li><a href="pets.html"><i class="chevron-nav icon-chevron-right"></i> pets</a></li>
		<li class="active"><a href="unittest.html"><i class="chevron-nav icon-white icon-chevron-right"></i> unittest</a></li>
	</ul>
</div>
<div class='span9'>
	<h1>unittest</h1>
	<p>
		exports <a href="matcher.html">matcher</a></p>
	<hr>
	<dl class=dl-horizontal>
		<dt>Top-Level Variables</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=unittest.html#ERROR>ERROR</a>: dynamic<br>
			<i class=icon-minus-sign></i> <a href=unittest.html#FAIL>FAIL</a>: dynamic<br>
			<i class=icon-minus-sign></i> <a href=unittest.html#PASS>PASS</a>: dynamic<br>
			<i class=icon-minus-sign></i> <a href=unittest.html#groupSep>groupSep</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#testCases>testCases</a>: <a href=dart.core.html#List>List</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#testState>testState</a>: <a href=dart.core.html#Map>Map</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=unittest.html#currentTestCase>currentTestCase</a>: <a href=unittest.html#TestCase>TestCase</a><br>
			<i class=icon-circle-arrow-right></i> <a href=unittest.html#unittestConfiguration>unittestConfiguration</a>: <a href=unittest.html#Configuration>Configuration</a><br>
			<i class=icon-circle-arrow-left></i> <a href=unittest.html#unittestConfiguration=>unittestConfiguration=</a>(<a href=unittest.html#Configuration>Configuration</a> value)<br>
		</dd>
		<dt>Functions</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=unittest.html#disableTest>disableTest</a>(<a href=dart.core.html#int>int</a> testId): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#enableTest>enableTest</a>(<a href=dart.core.html#int>int</a> testId): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#ensureInitialized>ensureInitialized</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#expectAsync0>expectAsync0</a>(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#int>int</a> count, <a href=dart.core.html#int>int</a> max, <a href=dart.core.html#String>String</a> id): <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-ok-sign></i> <a href=unittest.html#expectAsync1>expectAsync1</a>(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#int>int</a> count, <a href=dart.core.html#int>int</a> max, <a href=dart.core.html#String>String</a> id): <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-ok-sign></i> <a href=unittest.html#expectAsync2>expectAsync2</a>(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#int>int</a> count, <a href=dart.core.html#int>int</a> max, <a href=dart.core.html#String>String</a> id): <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-ok-sign></i> <a href=unittest.html#expectAsyncUntil0>expectAsyncUntil0</a>(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#Function>Function</a> isDone, <a href=dart.core.html#String>String</a> id): <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-ok-sign></i> <a href=unittest.html#expectAsyncUntil1>expectAsyncUntil1</a>(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#Function>Function</a> isDone, <a href=dart.core.html#String>String</a> id): <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-ok-sign></i> <a href=unittest.html#expectAsyncUntil2>expectAsyncUntil2</a>(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#Function>Function</a> isDone, <a href=dart.core.html#String>String</a> id): <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-ok-sign></i> <a href=unittest.html#filterTests>filterTests</a>(dynamic testFilter): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#group>group</a>(<a href=dart.core.html#String>String</a> description, body): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#guardAsync>guardAsync</a>(<a href=dart.core.html#Function>Function</a> tryBody): dynamic<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#logMessage>logMessage</a>(<a href=dart.core.html#String>String</a> message): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#protectAsync0>protectAsync0</a>(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#String>String</a> id): <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-ok-sign></i> <a href=unittest.html#protectAsync1>protectAsync1</a>(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#String>String</a> id): <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-ok-sign></i> <a href=unittest.html#protectAsync2>protectAsync2</a>(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#String>String</a> id): <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-ok-sign></i> <a href=unittest.html#registerException>registerException</a>(dynamic e, dynamic trace): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#rerunTests>rerunTests</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#runTests>runTests</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#setSoloTest>setSoloTest</a>(<a href=dart.core.html#int>int</a> id): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#setUp>setUp</a>(<a href=dart.core.html#Function>Function</a> setupTest): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#skip_group>skip_group</a>(<a href=dart.core.html#String>String</a> description, body): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#skip_test>skip_test</a>(<a href=dart.core.html#String>String</a> spec, <a href=unittest.html#TestFunction>TestFunction</a> body): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#solo_group>solo_group</a>(<a href=dart.core.html#String>String</a> description, body): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#solo_test>solo_test</a>(<a href=dart.core.html#String>String</a> spec, <a href=unittest.html#TestFunction>TestFunction</a> body): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#tearDown>tearDown</a>(<a href=dart.core.html#Function>Function</a> teardownTest): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#test>test</a>(<a href=dart.core.html#String>String</a> spec, <a href=unittest.html#TestFunction>TestFunction</a> body): void<br>
		</dd>
		<dt>Typedefs</dt>
		<dd>
			<i class=icon-cog></i> <a href=unittest.html#TestFunction>TestFunction</a>(): dynamic<br>
		</dd>
		<dt>Classes</dt>
		<dd>
			<i class=icon-leaf></i> <a href=unittest.html#Configuration>Configuration</a><br>
			<i class=icon-leaf></i> <a href=unittest.html#TestCase>TestCase</a><br>
		</dd>
	</dl>
	<div class=indent>
		<p>A library for writing dart unit tests. </p>
<p><h5> Installing </h5> </p>
<p>Use <a class=code>pub</a><a class=code></a> to install this package. Add the following to your <code>pubspec.yaml</code> file. </p>
<p><pre>dependencies:
  unittest: any
</pre>Then run <code>pub install</code>. </p>
<p>For more information, see the <a class=code>unittest package on pub.dartlang.org</a><a class=code>pkg</a>. </p>
<p>See the <a class=code>Getting Started</a>(http://pub.dartlang.org/doc) guide for more details. </p>
<p><h5>Concepts</h5> </p>
<p><ul><li><b>Tests</b>: Tests are specified via the top-level function <a class=code>test</a>, they can be</li></ul>organized together using <a class=code>group</a>. <ul><li><b>Checks</b>: Test expectations can be specified via <a class=code>expect</a></li></ul><ul><li><b>Matchers</b>: <a class=code>expect</a> assertions are written declaratively using the</li></ul><a class=code>Matcher</a> class. <ul><li><b>Configuration</b>: The framework can be adapted by setting</li></ul><a class=code>unittestConfiguration</a> with a <a class=code>Configuration</a>. See the other libraries in the <code>unittest</code> package for alternative implementations of <a class=code>Configuration</a> including <code>compact_vm_config.dart</code>, <code>html_config.dart</code> and <code>html_enhanced_config.dart</code>. </p>
<p><h5>Examples</h5> </p>
<p>A trivial test: </p>
<p><pre>import 'package:unittest/unittest.dart';
main() {
  test('this is a test', () {
    int x = 2 + 3;
    expect(x, equals(5));
  });
}
</pre>Multiple tests: </p>
<p><pre>import 'package:unittest/unittest.dart';
main() {
  test('this is a test', () {
    int x = 2 + 3;
    expect(x, equals(5));
  });
  test('this is another test', () {
    int x = 2 + 3;
    expect(x, equals(5));
  });
}
</pre>Multiple tests, grouped by category: </p>
<p><pre>import 'package:unittest/unittest.dart';
main() {
  group('group A', () {
    test('test A.1', () {
      int x = 2 + 3;
      expect(x, equals(5));
    });
    test('test A.2', () {
      int x = 2 + 3;
      expect(x, equals(5));
    });
  });
  group('group B', () {
    test('this B.1', () {
      int x = 2 + 3;
      expect(x, equals(5));
    });
  });
}
</pre>Asynchronous tests: if callbacks expect between 0 and 2 positional arguments, depending on the suffix of expectAsyncX(). expectAsyncX() will wrap a function into a new callback and will not consider the test complete until that callback is run. A count argument can be provided to specify the number of times the callback should be called (the default is 1). </p>
<p><pre>import 'package:unittest/unittest.dart';
import 'dart:isolate';
main() {
  test('callback is executed once', () {
    // wrap the callback of an asynchronous call with [expectAsync0] if
    // the callback takes 0 arguments...
    var timer = Timer.run(expectAsync0(() {
      int x = 2 + 3;
      expect(x, equals(5));
    }));
  });

  test('callback is executed twice', () {
    var callback = expectAsync0(() {
      int x = 2 + 3;
      expect(x, equals(5));
    }, count: 2); // &lt;-- we can indicate multiplicity to [expectAsync0]
    Timer.run(callback);
    Timer.run(callback);
  });
}
</pre>expectAsyncX() will wrap the callback code in a try/catch handler to handle exceptions (treated as test failures). There may be times when the number of times a callback should be called is non-deterministic. In this case a dummy callback can be created with expectAsync0((){}) and this can be called from the real callback when it is finally complete. In this case the body of the callback should be protected within a call to guardAsync(); this will ensure that exceptions are properly handled. </p>
<p>A variation on this is expectAsyncUntilX(), which takes a callback as the first parameter and a predicate function as the second parameter; after each time * the callback is called, the predicate function will be called; if it returns false the test will still be considered incomplete. </p>
<p>Test functions can return <a class=code>Future</a>s, which provide another way of doing asynchronous tests. The test framework will handle exceptions thrown by the Future, and will advance to the next test when the Future is complete. It is still important to use expectAsync/guardAsync with any parts of the test that may be invoked from a top level context (for example, with Timer.run()], as the Future exception handler may not capture exceptions in such code. </p>
<p>Note: due to some language limitations we have to use different functions depending on the number of positional arguments of the callback. In the future, we plan to expose a single <code>expectAsync</code> function that can be used regardless of the number of positional arguments. This requires new langauge features or fixes to the current spec (e.g. see <a class=code>Issue 2706</a>(http://dartbug.com/2706)). </p>
<p>Meanwhile, we plan to add this alternative API for callbacks of more than 2 arguments or that take named parameters. (this is not implemented yet, but will be coming here soon). </p>
<p><pre>import 'package:unittest/unittest.dart';
import 'dart:isolate';
main() {
  test('callback is executed', () {
    // indicate ahead of time that an async callback is expected.
    var async = startAsync();
    Timer.run(() {
      // Guard the body of the callback, so errors are propagated
      // correctly.
      guardAsync(() {
        int x = 2 + 3;
        expect(x, equals(5));
      });
      // indicate that the asynchronous callback was invoked.
      async.complete();
    });
  });
}
</pre><a class=code>pub</a>: http://pub.dartlang.org <a class=code>pkg</a>: http://pub.dartlang.org/packages/unittest</p>
	</div>
	<h4>Top-Level Variables</h4>
	<div class=indent>
		<b><a id=ERROR></a><i class=icon-minus-sign></i> static const dynamic ERROR = 'error'</b>
		<div class=indent></div>
		<b><a id=FAIL></a><i class=icon-minus-sign></i> static const dynamic FAIL = 'fail'</b>
		<div class=indent></div>
		<b><a id=PASS></a><i class=icon-minus-sign></i> static const dynamic PASS = 'pass'</b>
		<div class=indent>
			<p>Test case result strings.</p>
		</div>
		<b><a id=groupSep></a><i class=icon-minus-sign></i> static <a href=dart.core.html#String>String</a> groupSep</b>
		<div class=indent>
			<p>Separator used between group names and test names.</p>
		</div>
		<b><a id=testCases></a><i class=icon-minus-sign></i> static final <a href=dart.core.html#List>List</a> testCases</b>
		<div class=indent>
			<p>Tests executed in this suite.</p>
		</div>
		<b><a id=testState></a><i class=icon-minus-sign></i> static <a href=dart.core.html#Map>Map</a> testState</b>
		<div class=indent>
			<p>A map that can be used to communicate state between a test driver or main() function and the tests, particularly when these two are otherwise independent. For example, a test driver that starts an HTTP server and then runs tests that access that server could use this as a way of communicating the server port to the tests.</p>
		</div>
	</div>
	<h4>Getters and Setters</h4>
	<div class=indent>
		<b><a id=currentTestCase></a><i class=icon-circle-arrow-right></i> static <a href=unittest.html#TestCase>TestCase</a> get currentTestCase</b>
		<div class=indent>
			<p><a class=code>TestCase</a> currently being executed.</p>
		</div>
		<b><a id=unittestConfiguration></a><i class=icon-circle-arrow-right></i> static <a href=unittest.html#Configuration>Configuration</a> get unittestConfiguration</b>
		<div class=indent>
			<p><a class=code>Configuration</a> used by the unittest library. Note that if a configuration has not been set, calling this getter will create a default configuration.</p>
		</div>
		<b><a id=unittestConfiguration=></a><i class=icon-circle-arrow-left></i> static set unittestConfiguration=(<a href=unittest.html#Configuration>Configuration</a> value)</b>
		<div class=indent>
			<p>Sets the <a class=code>Configuration</a> used by the unittest library. </p>
<p>Throws a <a class=code>StateError</a> if there is an existing, incompatible value.</p>
		</div>
	</div>
	<h4>Functions</h4>
	<div class=indent>
		<b><a id=disableTest></a><i class=icon-ok-sign></i> static void disableTest(<a href=dart.core.html#int>int</a> testId)</b>
		<div class=indent>
			<p>Disable a test by ID.</p>
		</div>
		<b><a id=enableTest></a><i class=icon-ok-sign></i> static void enableTest(<a href=dart.core.html#int>int</a> testId)</b>
		<div class=indent>
			<p>Enable a test by ID.</p>
		</div>
		<b><a id=ensureInitialized></a><i class=icon-ok-sign></i> static void ensureInitialized()</b>
		<div class=indent>
			<p>Lazily initializes the test library if not already initialized.</p>
		</div>
		<b><a id=expectAsync0></a><i class=icon-ok-sign></i> static <a href=dart.core.html#Function>Function</a> expectAsync0(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#int>int</a> count, <a href=dart.core.html#int>int</a> max, <a href=dart.core.html#String>String</a> id)</b>
		<div class=indent>
			<p>Indicate that <a class=code>callback</a> is expected to be called a <a class=code>count</a> number of times (by default 1). The unittest framework will wait for the callback to run the specified <a class=code>count</a> times before it continues with the following test.  Using <a class=code>expectAsync0</a> will also ensure that errors that occur within <a class=code>callback</a> are tracked and reported. <a class=code>callback</a> should take 0 positional arguments (named arguments are not supported). <a class=code>id</a> can be used to provide more descriptive error messages if the callback is called more often than expected. <a class=code>max</a> can be used to specify an upper bound on the number of calls; if this is exceeded the test will fail (or be marked as in error if it was already complete). A value of 0 for <a class=code>max</a> (the default) will set the upper bound to the same value as <a class=code>count</a>; i.e. the callback should be called exactly <a class=code>count</a> times. A value of -1 for <a class=code>max</a> will mean no upper bound.</p>
		</div>
		<b><a id=expectAsync1></a><i class=icon-ok-sign></i> static <a href=dart.core.html#Function>Function</a> expectAsync1(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#int>int</a> count, <a href=dart.core.html#int>int</a> max, <a href=dart.core.html#String>String</a> id)</b>
		<div class=indent>
			<p>Like <a class=code>expectAsync0</a> but <a class=code>callback</a> should take 1 positional argument.</p>
		</div>
		<b><a id=expectAsync2></a><i class=icon-ok-sign></i> static <a href=dart.core.html#Function>Function</a> expectAsync2(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#int>int</a> count, <a href=dart.core.html#int>int</a> max, <a href=dart.core.html#String>String</a> id)</b>
		<div class=indent>
			<p>Like <a class=code>expectAsync0</a> but <a class=code>callback</a> should take 2 positional arguments.</p>
		</div>
		<b><a id=expectAsyncUntil0></a><i class=icon-ok-sign></i> static <a href=dart.core.html#Function>Function</a> expectAsyncUntil0(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#Function>Function</a> isDone, <a href=dart.core.html#String>String</a> id)</b>
		<div class=indent>
			<p>Indicate that <a class=code>callback</a> is expected to be called until <a class=code>isDone</a> returns true. The unittest framework check <a class=code>isDone</a> after each callback and only when it returns true will it continue with the following test. Using <a class=code>expectAsyncUntil0</a> will also ensure that errors that occur within <a class=code>callback</a> are tracked and reported. <a class=code>callback</a> should take 0 positional arguments (named arguments are not supported). <a class=code>id</a> can be used to identify the callback in error messages (for example if it is called after the test case is complete).</p>
		</div>
		<b><a id=expectAsyncUntil1></a><i class=icon-ok-sign></i> static <a href=dart.core.html#Function>Function</a> expectAsyncUntil1(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#Function>Function</a> isDone, <a href=dart.core.html#String>String</a> id)</b>
		<div class=indent>
			<p>Like <a class=code>expectAsyncUntil0</a> but <a class=code>callback</a> should take 1 positional argument.</p>
		</div>
		<b><a id=expectAsyncUntil2></a><i class=icon-ok-sign></i> static <a href=dart.core.html#Function>Function</a> expectAsyncUntil2(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#Function>Function</a> isDone, <a href=dart.core.html#String>String</a> id)</b>
		<div class=indent>
			<p>Like <a class=code>expectAsyncUntil0</a> but <a class=code>callback</a> should take 2 positional arguments.</p>
		</div>
		<b><a id=filterTests></a><i class=icon-ok-sign></i> static void filterTests(dynamic testFilter)</b>
		<div class=indent>
			<p>Filter the tests. <a class=code>testFilter</a> can be a <a class=code>RegExp</a>, a <a class=code>String</a> or a predicate function. This is different to enabling/disabling tests in that it removes the tests completely.</p>
		</div>
		<b><a id=group></a><i class=icon-ok-sign></i> static void group(<a href=dart.core.html#String>String</a> description, body)</b>
		<div class=indent>
			<p>Creates a new named group of tests. Calls to group() or test() within the body of the function passed to this will inherit this group's description.</p>
		</div>
		<b><a id=guardAsync></a><i class=icon-ok-sign></i> static dynamic guardAsync(<a href=dart.core.html#Function>Function</a> tryBody)</b>
		<div class=indent>
			<p>Run <a class=code>tryBody</a> guarded in a try-catch block. If an exception is thrown, it is passed to the corresponding test. </p>
<p>The value returned by <a class=code>tryBody</a> (if any) is returned by <a class=code>guardAsync</a>.</p>
		</div>
		<b><a id=logMessage></a><i class=icon-ok-sign></i> static void logMessage(<a href=dart.core.html#String>String</a> message)</b>
		<div class=indent>
			<p>Can be called by tests to log status. Tests should use this instead of <a class=code>print</a>.</p>
		</div>
		<b><a id=protectAsync0></a><i class=icon-ok-sign></i> static <a href=dart.core.html#Function>Function</a> protectAsync0(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#String>String</a> id)</b>
		<div class=indent>
			<p>Wraps the <a class=code>callback</a> in a new function and returns that function. The new function will be able to handle exceptions by directing them to the correct test. This is thus similar to expectAsync0. Use it to wrap any callbacks that might optionally be called but may never be called during the test. <a class=code>callback</a> should take 0 positional arguments (named arguments are not supported). <a class=code>id</a> can be used to identify the callback in error messages (for example if it is called after the test case is complete).</p>
		</div>
		<b><a id=protectAsync1></a><i class=icon-ok-sign></i> static <a href=dart.core.html#Function>Function</a> protectAsync1(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#String>String</a> id)</b>
		<div class=indent>
			<p>Like <a class=code>protectAsync0</a> but <a class=code>callback</a> should take 1 positional argument.</p>
		</div>
		<b><a id=protectAsync2></a><i class=icon-ok-sign></i> static <a href=dart.core.html#Function>Function</a> protectAsync2(<a href=dart.core.html#Function>Function</a> callback, <a href=dart.core.html#String>String</a> id)</b>
		<div class=indent>
			<p>Like <a class=code>protectAsync0</a> but <a class=code>callback</a> should take 2 positional arguments.</p>
		</div>
		<b><a id=registerException></a><i class=icon-ok-sign></i> static void registerException(dynamic e, dynamic trace)</b>
		<div class=indent>
			<p>Registers that an exception was caught for the current test.</p>
		</div>
		<b><a id=rerunTests></a><i class=icon-ok-sign></i> static void rerunTests()</b>
		<div class=indent></div>
		<b><a id=runTests></a><i class=icon-ok-sign></i> static void runTests()</b>
		<div class=indent>
			<p>Runs all queued tests, one at a time.</p>
		</div>
		<b><a id=setSoloTest></a><i class=icon-ok-sign></i> static void setSoloTest(<a href=dart.core.html#int>int</a> id)</b>
		<div class=indent>
			<p>Select a solo test by ID.</p>
		</div>
		<b><a id=setUp></a><i class=icon-ok-sign></i> static void setUp(<a href=dart.core.html#Function>Function</a> setupTest)</b>
		<div class=indent>
			<p>Register a <a class=code>setUp</a> function for a test <a class=code>group</a>. This function will be called before each test in the group is run. <a class=code>setUp</a> and <a class=code>tearDown</a> should be called within the <a class=code>group</a> before any calls to <a class=code>test</a>. The <a class=code>setupTest</a> function can be asynchronous; in this case it must return a <a class=code>Future</a>.</p>
		</div>
		<b><a id=skip_group></a><i class=icon-ok-sign></i> static void skip_group(<a href=dart.core.html#String>String</a> description, body)</b>
		<div class=indent>
			<p>Like <a class=code>skip_test</a>, but for groups.</p>
		</div>
		<b><a id=skip_test></a><i class=icon-ok-sign></i> static void skip_test(<a href=dart.core.html#String>String</a> spec, <a href=unittest.html#TestFunction>TestFunction</a> body)</b>
		<div class=indent>
			<p>Convenience function for skipping a test.</p>
		</div>
		<b><a id=solo_group></a><i class=icon-ok-sign></i> static void solo_group(<a href=dart.core.html#String>String</a> description, body)</b>
		<div class=indent>
			<p>Like <a class=code>solo_test</a>, but for groups.</p>
		</div>
		<b><a id=solo_test></a><i class=icon-ok-sign></i> static void solo_test(<a href=dart.core.html#String>String</a> spec, <a href=unittest.html#TestFunction>TestFunction</a> body)</b>
		<div class=indent>
			<p>Creates a new test case with the given description and body. The description will include the descriptions of any surrounding group() calls. </p>
<p>If we use <a class=code>solo_test</a> (or <a class=code>solo_group</a>) instead of test, then all non-solo tests will be disabled. Note that if we use <a class=code>solo_group</a>, all tests in the group will be enabled, regardless of whether they use <a class=code>test</a> or <a class=code>solo_test</a>, or whether they are in a nested <a class=code>group</a> vs <a class=code>solo_group</a>. Put another way, if there are any calls to <a class=code>solo_test</a> or <a class=code>solo_group</a> in a test file, all tests that are not inside a <a class=code>solo_group</a> will be disabled unless they are <a class=code>solo_test</a>s. </p>
<p><a class=code>skip_test</a> and <a class=code>skip_group</a> take precedence over soloing, by virtue of the fact that they are effectively no-ops.</p>
		</div>
		<b><a id=tearDown></a><i class=icon-ok-sign></i> static void tearDown(<a href=dart.core.html#Function>Function</a> teardownTest)</b>
		<div class=indent>
			<p>Register a <a class=code>tearDown</a> function for a test <a class=code>group</a>. This function will be called after each test in the group is run. Note that if groups are nested only the most locally scoped <a class=code>teardownTest</a> function will be run. <a class=code>setUp</a> and <a class=code>tearDown</a> should be called within the <a class=code>group</a> before any calls to <a class=code>test</a>. The <a class=code>teardownTest</a> function can be asynchronous; in this case it must return a <a class=code>Future</a>.</p>
		</div>
		<b><a id=test></a><i class=icon-ok-sign></i> static void test(<a href=dart.core.html#String>String</a> spec, <a href=unittest.html#TestFunction>TestFunction</a> body)</b>
		<div class=indent>
			<p>Creates a new test case with the given description and body. The description will include the descriptions of any surrounding group() calls.</p>
		</div>
	</div>
	<h4>Typedefs</h4>
	<div class=indent>
		<b><a id=TestFunction></a><i class=icon-cog></i> typedef dynamic TestFunction(): </b>
		<div class=indent>
			<p>Signature for a test function.</p>
		</div>
	</div>
	<a id=Configuration></a><hr>
	<h4>
		<i class=icon-leaf></i> Class Configuration</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=unittest.html#Configuration.autoStart>autoStart</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#Configuration.name>name</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#Configuration.stopTestOnExpectFailure>stopTestOnExpectFailure</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#Configuration.throwOnTestFailures>throwOnTestFailures</a>: <a href=dart.core.html#bool>bool</a><br>
		</dd>
		<dt>Constructors</dt>
		<dd>
			<i class=icon-plus-sign></i> <a href=unittest.html#Configuration.>Configuration</a>()<br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.formatResult>formatResult</a>(<a href=unittest.html#TestCase>TestCase</a> testCase): <a href=dart.core.html#String>String</a><br>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.handleExternalError>handleExternalError</a>(dynamic e, <a href=dart.core.html#String>String</a> message, <a href=dart.core.html#String>String</a> stack): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.onDone>onDone</a>(<a href=dart.core.html#bool>bool</a> success): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.onExpectFailure>onExpectFailure</a>(<a href=dart.core.html#String>String</a> reason): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.onInit>onInit</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.onLogMessage>onLogMessage</a>(<a href=unittest.html#TestCase>TestCase</a> testCase, <a href=dart.core.html#String>String</a> message): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.onStart>onStart</a>(): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.onSummary>onSummary</a>(<a href=dart.core.html#int>int</a> passed, <a href=dart.core.html#int>int</a> failed, <a href=dart.core.html#int>int</a> errors, <a href=dart.core.html#List>List</a>&lt;<a href=unittest.html#TestCase>TestCase</a>&gt; results, <a href=dart.core.html#String>String</a> uncaughtError): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.onTestResult>onTestResult</a>(<a href=unittest.html#TestCase>TestCase</a> testCase): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.onTestResultChanged>onTestResultChanged</a>(<a href=unittest.html#TestCase>TestCase</a> testCase): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#Configuration.onTestStart>onTestStart</a>(<a href=unittest.html#TestCase>TestCase</a> testCase): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>Hooks to configure the unittest library for different platforms. This class implements the API in a platform-independent way. Tests that want to take advantage of the platform can create a subclass and override methods from this class.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=Configuration.autoStart></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> autoStart</b>
	<div class=indent>
		<p>If true, then tests are started automatically (otherwise <a class=code>runTests</a> must be called explicitly after the tests are set up.</p>
	</div>
	<b><a id=Configuration.name></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> name</b>
	<div class=indent>
		<p>Subclasses can override this with something useful for diagnostics. Particularly useful in cases where we have parent/child configurations such as layout tests.</p>
	</div>
	<b><a id=Configuration.stopTestOnExpectFailure></a><i class=icon-minus-sign></i> <a href=dart.core.html#bool>bool</a> stopTestOnExpectFailure</b>
	<div class=indent>
		<p>If true (the default), then tests will stop after the first failed <a class=code>expect</a>. If false, failed <a class=code>expect</a>s will not cause the test to stop (other exceptions will still terminate the test).</p>
	</div>
	<b><a id=Configuration.throwOnTestFailures></a><i class=icon-minus-sign></i> <a href=dart.core.html#bool>bool</a> throwOnTestFailures</b>
	<div class=indent>
		<p>If true (the default), throw an exception at the end if any tests failed.</p>
	</div>
	<h4>Constructors</h4>
	<b><a id=Configuration.></a><i class=icon-plus-sign></i> Configuration()</b>
	<div class=indent>
		<p>The constructor sets up a failure handler for <a class=code>expect</a> that redirects <a class=code>expect</a> failures to <a class=code>onExpectFailure</a>.</p>
	</div>
	<h4>Methods</h4>
	<b><a id=Configuration.formatResult></a><i class=icon-ok-sign></i> <a href=dart.core.html#String>String</a> formatResult(<a href=unittest.html#TestCase>TestCase</a> testCase)</b>
	<div class=indent>
		<p>Format a test result.</p>
	</div>
	<b><a id=Configuration.handleExternalError></a><i class=icon-ok-sign></i> void handleExternalError(dynamic e, <a href=dart.core.html#String>String</a> message, <a href=dart.core.html#String>String</a> stack)</b>
	<div class=indent>
		<p>Handle errors that happen outside the tests.</p>
	</div>
	<b><a id=Configuration.onDone></a><i class=icon-ok-sign></i> void onDone(<a href=dart.core.html#bool>bool</a> success)</b>
	<div class=indent>
		<p>Called when the unittest framework is done running. <a class=code>success</a> indicates whether all tests passed successfully.</p>
	</div>
	<b><a id=Configuration.onExpectFailure></a><i class=icon-ok-sign></i> void onExpectFailure(<a href=dart.core.html#String>String</a> reason)</b>
	<div class=indent>
		<p>Handles failures from expect(). The default in this base configuration is to throw an exception;</p>
	</div>
	<b><a id=Configuration.onInit></a><i class=icon-ok-sign></i> void onInit()</b>
	<div class=indent>
		<p>Called as soon as the unittest framework becomes initialized. This is done even before tests are added to the test framework. It might be used to determine/debug errors that occur before the test harness starts executing. It is also used to tell the vm or browser that tests are going to be run asynchronously and that the process should wait until they are done.</p>
	</div>
	<b><a id=Configuration.onLogMessage></a><i class=icon-ok-sign></i> void onLogMessage(<a href=unittest.html#TestCase>TestCase</a> testCase, <a href=dart.core.html#String>String</a> message)</b>
	<div class=indent>
		<p>Handles the logging of messages by a test case. The default in this base configuration is to call print();</p>
	</div>
	<b><a id=Configuration.onStart></a><i class=icon-ok-sign></i> void onStart()</b>
	<div class=indent>
		<p>Called as soon as the unittest framework starts running.</p>
	</div>
	<b><a id=Configuration.onSummary></a><i class=icon-ok-sign></i> void onSummary(<a href=dart.core.html#int>int</a> passed, <a href=dart.core.html#int>int</a> failed, <a href=dart.core.html#int>int</a> errors, <a href=dart.core.html#List>List</a>&lt;<a href=unittest.html#TestCase>TestCase</a>&gt; results, <a href=dart.core.html#String>String</a> uncaughtError)</b>
	<div class=indent>
		<p>Called with the result of all test cases. The default implementation prints the result summary using the built-in <a class=code>print</a> command. Browser tests commonly override this to reformat the output. </p>
<p>When <a class=code>uncaughtError</a> is not null, it contains an error that occured outside of tests (e.g. setting up the test).</p>
	</div>
	<b><a id=Configuration.onTestResult></a><i class=icon-ok-sign></i> void onTestResult(<a href=unittest.html#TestCase>TestCase</a> testCase)</b>
	<div class=indent>
		<p>Called when each test is first completed. Useful to show intermediate progress on a test suite. Derived classes should call this first  before their own override code.</p>
	</div>
	<b><a id=Configuration.onTestResultChanged></a><i class=icon-ok-sign></i> void onTestResultChanged(<a href=unittest.html#TestCase>TestCase</a> testCase)</b>
	<div class=indent>
		<p>Called when an already completed test changes state; for example a test that was marked as passing may later be marked as being in error because it still had callbacks being invoked.</p>
	</div>
	<b><a id=Configuration.onTestStart></a><i class=icon-ok-sign></i> void onTestStart(<a href=unittest.html#TestCase>TestCase</a> testCase)</b>
	<div class=indent>
		<p>Called when each test starts. Useful to show intermediate progress on a test suite. Derived classes should call this first before their own override code.</p>
	</div>
	<a id=TestCase></a><hr>
	<h4>
		<i class=icon-leaf></i> Class TestCase</h4>
	<dl class=dl-horizontal>
		<dt>Fields</dt>
		<dd>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.currentGroup>currentGroup</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.description>description</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.enabled>enabled</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.id>id</a>: <a href=dart.core.html#int>int</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.isComplete>isComplete</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.message>message</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.result>result</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.runningTime>runningTime</a>: <a href=dart.core.html#Duration>Duration</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.setUp>setUp</a>: <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.stackTrace>stackTrace</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.startTime>startTime</a>: <a href=dart.core.html#DateTime>DateTime</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.tearDown>tearDown</a>: <a href=dart.core.html#Function>Function</a><br>
			<i class=icon-minus-sign></i> <a href=unittest.html#TestCase.testFunction>testFunction</a>: <a href=unittest.html#TestFunction>TestFunction</a><br>
		</dd>
		<dt>Getters and Setters</dt>
		<dd>
			<i class=icon-circle-arrow-right></i> <a href=unittest.html#isComplete>isComplete</a>: <a href=dart.core.html#bool>bool</a><br>
			<i class=icon-circle-arrow-right></i> <a href=unittest.html#message>message</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-circle-arrow-right></i> <a href=unittest.html#result>result</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-circle-arrow-right></i> <a href=unittest.html#runningTime>runningTime</a>: <a href=dart.core.html#Duration>Duration</a><br>
			<i class=icon-circle-arrow-right></i> <a href=unittest.html#stackTrace>stackTrace</a>: <a href=dart.core.html#String>String</a><br>
			<i class=icon-circle-arrow-right></i> <a href=unittest.html#startTime>startTime</a>: <a href=dart.core.html#DateTime>DateTime</a><br>
		</dd>
		<dt>Methods</dt>
		<dd>
			<i class=icon-ok-sign></i> <a href=unittest.html#TestCase.error>error</a>(<a href=dart.core.html#String>String</a> messageText, <a href=dart.core.html#String>String</a> stack): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#TestCase.fail>fail</a>(<a href=dart.core.html#String>String</a> messageText, <a href=dart.core.html#String>String</a> stack): void<br>
			<i class=icon-ok-sign></i> <a href=unittest.html#TestCase.pass>pass</a>(): void<br>
		</dd>
	</dl>
	<div class=indent>
		<p>Represents the state for an individual unit test. </p>
<p>Create by calling <a class=code>test</a> or <a class=code>solo_test</a>.</p>
	</div>
	<h4>Fields</h4>
	<b><a id=TestCase.currentGroup></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> currentGroup</b>
	<div class=indent>
		<p>The group (or groups) under which this test is running.</p>
	</div>
	<b><a id=TestCase.description></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> description</b>
	<div class=indent>
		<p>A description of what the test is specifying.</p>
	</div>
	<b><a id=TestCase.enabled></a><i class=icon-minus-sign></i> <a href=dart.core.html#bool>bool</a> enabled</b>
	<div class=indent></div>
	<b><a id=TestCase.id></a><i class=icon-minus-sign></i> final <a href=dart.core.html#int>int</a> id</b>
	<div class=indent>
		<p>Identifier for this test.</p>
	</div>
	<b><a id=TestCase.isComplete></a><i class=icon-minus-sign></i> final <a href=dart.core.html#bool>bool</a> isComplete</b>
	<div class=indent></div>
	<b><a id=TestCase.message></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> message</b>
	<div class=indent></div>
	<b><a id=TestCase.result></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> result</b>
	<div class=indent></div>
	<b><a id=TestCase.runningTime></a><i class=icon-minus-sign></i> final <a href=dart.core.html#Duration>Duration</a> runningTime</b>
	<div class=indent></div>
	<b><a id=TestCase.setUp></a><i class=icon-minus-sign></i> <a href=dart.core.html#Function>Function</a> setUp</b>
	<div class=indent>
		<p>The setup function to call before the test, if any.</p>
	</div>
	<b><a id=TestCase.stackTrace></a><i class=icon-minus-sign></i> final <a href=dart.core.html#String>String</a> stackTrace</b>
	<div class=indent></div>
	<b><a id=TestCase.startTime></a><i class=icon-minus-sign></i> final <a href=dart.core.html#DateTime>DateTime</a> startTime</b>
	<div class=indent></div>
	<b><a id=TestCase.tearDown></a><i class=icon-minus-sign></i> <a href=dart.core.html#Function>Function</a> tearDown</b>
	<div class=indent>
		<p>The teardown function to call after the test, if any.</p>
	</div>
	<b><a id=TestCase.testFunction></a><i class=icon-minus-sign></i> <a href=unittest.html#TestFunction>TestFunction</a> testFunction</b>
	<div class=indent>
		<p>The body of the test case.</p>
	</div>
	<h4>Getters and Setters</h4>
	<b><a id=isComplete></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#bool>bool</a> get isComplete</b>
	<div class=indent></div>
	<b><a id=message></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#String>String</a> get message</b>
	<div class=indent>
		<p>Error or failure message.</p>
	</div>
	<b><a id=result></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#String>String</a> get result</b>
	<div class=indent>
		<p>One of <a class=code>PASS</a>, <a class=code>FAIL</a>, <a class=code>ERROR</a>, or <a class=code>null</a> if the test hasn't run yet.</p>
	</div>
	<b><a id=runningTime></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#Duration>Duration</a> get runningTime</b>
	<div class=indent></div>
	<b><a id=stackTrace></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#String>String</a> get stackTrace</b>
	<div class=indent>
		<p>Stack trace associated with this test, or <a class=code>null</a> if it succeeded.</p>
	</div>
	<b><a id=startTime></a><i class=icon-circle-arrow-right></i> <a href=dart.core.html#DateTime>DateTime</a> get startTime</b>
	<div class=indent></div>
	<h4>Methods</h4>
	<b><a id=TestCase.error></a><i class=icon-ok-sign></i> void error(<a href=dart.core.html#String>String</a> messageText, <a href=dart.core.html#String>String</a> stack)</b>
	<div class=indent></div>
	<b><a id=TestCase.fail></a><i class=icon-ok-sign></i> void fail(<a href=dart.core.html#String>String</a> messageText, <a href=dart.core.html#String>String</a> stack)</b>
	<div class=indent></div>
	<b><a id=TestCase.pass></a><i class=icon-ok-sign></i> void pass()</b>
	<div class=indent></div>
	<hr>
</div>
</div>
</div>
<footer>
</footer>
</body>
</html>
